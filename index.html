<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="双手扶着后腰，双眼透着贫穷">
<meta property="og:type" content="website">
<meta property="og:title" content="M'S BLOG">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="M'S BLOG">
<meta property="og:description" content="双手扶着后腰，双眼透着贫穷">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="M'S BLOG">
<meta name="twitter:description" content="双手扶着后腰，双眼透着贫穷">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> M'S BLOG </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">M'S BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/02/java原型模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="m">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="M'S BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/02/java原型模式/" itemprop="url">
                  java原型模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-02T11:49:47+08:00">
                2017-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>在开发过程中，有时会遇到为一个类创建多个实例的情况，这些实例内部成员往往完全相同或有细微的差异，而且实例的创建开销比较大或者需要输入较多参数，如果能通过复制一个已创建的对象实例来重复创建多个相同的对象，这就可以大大减少创建对象的开销，这个时候就需要原型模式。</p>
<h2 id="二、模式详解"><a href="#二、模式详解" class="headerlink" title="二、模式详解"></a>二、模式详解</h2><h3 id="1、模式分析"><a href="#1、模式分析" class="headerlink" title="1、模式分析"></a>1、模式分析</h3><p>原型模式可以通过一个对象实例确定创建对象的种类，并且通过拷贝创建新的实例。总得来说，原型模式实际上就是从一个对象创建另一个新的对象，使新的对象有具有原对象的特征。<br>图1给出了原型模式的UML图，可以看出原型模式的结构非常简单。首先，所有可以作为原型的类中都应该有一个用于复制自身的方法clone()，因此，我们可以抽象出一个抽象原型类或接口，该类中只有一个clone()，所有的具体原型类都要实现该方法并定义复制自身的具体行为。在客户端中通过调用具体原型对象的clone方法可以复制原型对象到一个新的对象中。</p>
<p><img src="/2017/05/02/java原型模式/1.jpg" alt="1"></p>
<h3 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a>2、具体实现</h3><p>原型模式是一种应用及其广泛的设计模式，Clone也是一种十分常见的操作，以至于在Java中，终极父类Object将Clone方法作为了所有类应具有的基本功能，并且Java也提供了Cloneable接口（关于Cloneable接口的细节，请看我另一篇博文：JavaSE学习随笔（一） Cloneable接口源码分析与技术细节），这都方便了原型模式的实现。<br>我们还是以一个例子来说明原型模式的具体实现和作用。考虑一个写简历的场景，简历中包括的信息有姓名、性别、年龄、家庭成员和工作经验几点内容。现在的需求为由于需要向多个公司投递建立简历，因此子创建了一份建立对象之后，还要求能够对已创建的简历进行复制。此时，恰好有几个另外有几个同学也想找工作，为了方便，就把已创建的作为模版，然后根据自身的情况作了一些修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 为了实现上述要求，我们首先定义一个工作经验类，里面有两个成员变量分别为工作时间和公司名称。</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkExperience</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="keyword">public</span> String timeArea = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">public</span> String company = <span class="keyword">null</span>;  </div><div class="line">         </div><div class="line">&#125;<span class="comment">/*WorkExperience*/</span>  </div><div class="line"></div><div class="line"><span class="comment">// 接着定义一个简历类，该类相当于UML图中的实体原型类，至于抽像原型类或接口，Java中已经我i我们提供了Cloneable接口，因此我们只需要实现它就可以了（实现的方法可以通过上文给// 出的链接到我另一篇博文中查看，在这里我直接给出了接口的实现），我们首先来看一种实现方式。</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resume</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="keyword">public</span> String name = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">public</span> Integer age = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">public</span> String sex = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt; famMem = <span class="keyword">new</span> ArrayList&lt;&gt;();  </div><div class="line">    <span class="keyword">public</span> WorkExperience work = <span class="keyword">null</span>;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Resume</span><span class="params">(String name)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">        work = <span class="keyword">new</span> WorkExperience();  </div><div class="line">    &#125;<span class="comment">// Resume  </span></div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">    &#125;<span class="comment">// setName  </span></div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPersonal</span><span class="params">(String sex, <span class="keyword">int</span> age, ArrayList&lt;String&gt; famMem)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.age = age;  </div><div class="line">        <span class="keyword">this</span>.sex = sex;  </div><div class="line">        <span class="keyword">this</span>.famMem = famMem;  </div><div class="line">    &#125;<span class="comment">// setPersonal  </span></div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWork</span><span class="params">(String timeArea, String company)</span> </span>&#123;  </div><div class="line">        work.timeArea = timeArea;  </div><div class="line">        work.company = company;  </div><div class="line">    &#125;<span class="comment">// setWork  </span></div><div class="line">      </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 重些clone()方法为public类型，并调用Object类的本地clone()方法。 </div><div class="line">     */  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> Resume <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;  </div><div class="line">        <span class="keyword">return</span> (Resume)<span class="keyword">super</span>.clone();   </div><div class="line">    &#125;<span class="comment">// clone  </span></div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">" "</span> + <span class="keyword">this</span>.sex + <span class="string">" "</span> + <span class="keyword">this</span>.age);  </div><div class="line">        System.out.print(<span class="string">"Family member: "</span>);  </div><div class="line">        <span class="keyword">for</span>(String elem : famMem)  </div><div class="line">            System.out.print(elem + <span class="string">" "</span>);  </div><div class="line">        System.out.println();  </div><div class="line">        System.out.print(<span class="string">"Work experience: "</span> + <span class="keyword">this</span>.work.timeArea);  </div><div class="line">        System.out.println(<span class="string">" "</span> + <span class="keyword">this</span>.work.company);  </div><div class="line">    &#125;<span class="comment">// display  </span></div><div class="line">      </div><div class="line">&#125;<span class="comment">/*Resume*/</span></div><div class="line"></div><div class="line"><span class="comment">// 接下来是客户端代码：</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeDemo</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;  </div><div class="line">        ArrayList&lt;String&gt; famMem = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 家庭成员名单  </span></div><div class="line">        famMem.add(<span class="string">"Papa"</span>);  </div><div class="line">        famMem.add(<span class="string">"Mama"</span>);  </div><div class="line">          </div><div class="line">        <span class="comment">// 创建初始简历  </span></div><div class="line">        Resume resume1 = <span class="keyword">new</span> Resume(<span class="string">"Jobs"</span>, famMem);  </div><div class="line">        resume1.setPersonal(<span class="string">"Male"</span>, <span class="number">26</span>);  </div><div class="line">        resume1.setWork(<span class="string">"2013/8/1 - 2015/6/30"</span>, <span class="string">"Huawei"</span>);  </div><div class="line">          </div><div class="line">        <span class="comment">// 通过简历1复制出简历2，并对家庭成员和工作经验进行修改  </span></div><div class="line">        Resume resume2 = resume1.clone();  </div><div class="line">        resume2.setName(<span class="string">"Tom"</span>);  </div><div class="line">        resume2.famMem.add(<span class="string">"Brother"</span>);  </div><div class="line">        resume2.setWork(<span class="string">"2015/7/1 - 2016/6/30"</span>, <span class="string">"Baidu"</span>);  </div><div class="line">          </div><div class="line">        resume1.display();  </div><div class="line">        resume2.display();  </div><div class="line">    &#125;<span class="comment">// main  </span></div><div class="line">      </div><div class="line">&#125;<span class="comment">/*Pritotype*/</span>  </div><div class="line"></div></pre></td></tr></table></figure>
<p>运行结果：<br><img src="/2017/05/02/java原型模式/2.jpg" alt="2"></p>
<p>从运行结果上看，虽然Tom成功复制了Jobs的简历，但是随后对Tom家庭成员和工作经验的修改却导致了Jobs的简历被同时修改，这是由于我们在实现clone() 方法时直接调用了Object类的本地clone()方法造成的，因为Object的clone()方法执行的是浅拷贝，因而Jobs和Tom的简历中的famMem和work字段都指向了同一个对象实例。要想实现深拷贝，就必须要修改clone()方法（详见：JavaSE学习随笔（一） Cloneable接口源码分析与技术细节）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resume</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="keyword">public</span> String name = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">public</span> String sex = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt; famMem = <span class="keyword">new</span> ArrayList&lt;&gt;();  </div><div class="line">    <span class="keyword">public</span> WorkExperience work = <span class="keyword">null</span>;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Resume</span><span class="params">(String name, ArrayList&lt;String&gt; famMem)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">        <span class="keyword">this</span>.famMem = famMem;  </div><div class="line">        work = <span class="keyword">new</span> WorkExperience();  </div><div class="line">    &#125;<span class="comment">// Resume  </span></div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">    &#125;<span class="comment">// setName  </span></div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPersonal</span><span class="params">(String sex, <span class="keyword">int</span> age)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.age = age;  </div><div class="line">        <span class="keyword">this</span>.sex = sex;  </div><div class="line">    &#125;<span class="comment">// setPersonal  </span></div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWork</span><span class="params">(String timeArea, String company)</span> </span>&#123;  </div><div class="line">        work.timeArea = timeArea;  </div><div class="line">        work.company = company;  </div><div class="line">    &#125;<span class="comment">// setWork  </span></div><div class="line">      </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 重些clone()方法为public类型，为每个字段都创建新的对象，已实现深拷贝功能。 </div><div class="line">     */  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> Resume <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;  </div><div class="line">        <span class="keyword">int</span> age = <span class="keyword">this</span>.age;  </div><div class="line">        String sex = <span class="keyword">this</span>.sex;  </div><div class="line">        String name = <span class="keyword">new</span> String(<span class="keyword">this</span>.name);  </div><div class="line">        ArrayList&lt;String&gt; famMem = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.famMem);  </div><div class="line">          </div><div class="line">        Resume copy = <span class="keyword">new</span> Resume(name, famMem);   </div><div class="line">        copy.setPersonal(sex, age);  </div><div class="line">        copy.setWork(<span class="keyword">this</span>.work.timeArea, <span class="keyword">this</span>.work.company);  </div><div class="line">        <span class="keyword">return</span> copy;  </div><div class="line">    &#125;<span class="comment">// clone  </span></div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">" "</span> + <span class="keyword">this</span>.sex + <span class="string">" "</span> + <span class="keyword">this</span>.age);  </div><div class="line">        System.out.print(<span class="string">"Family member: "</span>);  </div><div class="line">        <span class="keyword">for</span>(String elem : famMem)  </div><div class="line">            System.out.print(elem + <span class="string">" "</span>);  </div><div class="line">        System.out.println();  </div><div class="line">        System.out.print(<span class="string">"Work experience: "</span> + <span class="keyword">this</span>.work.timeArea);  </div><div class="line">        System.out.println(<span class="string">" "</span> + <span class="keyword">this</span>.work.company);  </div><div class="line">    &#125;<span class="comment">// display  </span></div><div class="line">      </div><div class="line">&#125;<span class="comment">/*Resume*/</span> </div></pre></td></tr></table></figure> 
<p>运行结果：<br><img src="/2017/05/02/java原型模式/3.jpg" alt="3"><br>可以看出，使clone()方法具备深拷贝功能后，复制后的建立与原简历被独立开来。</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>原型模式可以说是所有设计模式中最简单的一个，它没有复杂的继承体系，只需要使需要具有拷贝功能的类实现Cloneable接口并重写clone()方法即可。但它的应用却及其广泛，它将对一个对象中各个字段（不管是私有的还是共有的）的复制操作封装在了clone()方法中，这样，使用该类的用户就不需要对对象中的各个字段的细节进行了解，直接调用clone()方法就可以实现对象的拷贝，而且，通过clone()方法还可以为不同的字段设置被复制的权限，从而允许仅对可以被复制的字段进行复制。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/27/java工厂方法模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="m">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="M'S BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/27/java工厂方法模式/" itemprop="url">
                  java工厂方法模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-27T18:57:31+08:00">
                2017-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在阎宏博士的《JAVA与模式》一书中开头是这样描述工厂方法模式的：</p>
<p>　　<strong>工厂方法模式是类的创建模式，又叫做虚拟构造子(Virtual Constructor)模式或者多态性工厂（Polymorphic Factory）模式。</strong></p>
<p>　　<strong>工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。</strong></p>
<p>那么工厂方法模式是在什么场景下使用呢，下面就以本人的理解举例说明:</p>
<p>　　相信很多人都做过导入导出功能，就拿导出功能来说。有这么一个需求：XX系统需要支持对数据库中的员工薪资进行导出，并且支持多种格式如：HTML、CSV、PDF等，每种格式导出的结构有所不同，比如：财务跟其他人对导出薪资的HTML格式要求可能会不一样，因为财务可能需要特定的格式方便核算或其他用途。</p>
<p>　　如果使用简单工厂模式，则工厂类必定过于臃肿。因为简单工厂模式只有一个工厂类，它需要处理所有的创建的逻辑。假如以上需求暂时只支持3种导出的格式以及2种导出的结构，那工厂类则需要6个if else来创建6种不同的类型。如果日后需求不断增加，则后果不堪设想。</p>
<p>　　这时候就需要工厂方法模式来处理以上需求。在工厂方法模式中，核心的工厂类不再负责所有的对象的创建，而是将具体创建的工作交给子类去做。这个核心类则摇身一变，成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个类应当被实例化这种细节。</p>
<p>　　这种进一步抽象化的结果，使这种工厂方法模式可以用来允许系统在不修改具体工厂角色的情况下引进新的产品，这一特点无疑使得工厂方法模式具有超过简单工厂模式的优越性。下面就针对以上需求设计UML图：</p>
<p><img src="/2017/04/27/java工厂方法模式/1.jpg" alt="1"></p>
<p>从上图可以看出，这个使用的工厂方法模式的系统涉及到以下角色：</p>
<p>　　<strong>抽象工厂（ExportFactory）角色：担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。</strong></p>
<p>　　<strong>具体工厂（ExportHtmlFactory、ExportPdfFactory）角色：担任这个角色的是实现了抽象工厂接口的具体JAVA类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建导出类（如：ExportStandardHtmlFile）。</strong></p>
<p>　　<strong>抽象导出（ExportFile）角色：工厂方法模式所创建的对象的超类，也就是所有导出类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。</strong></p>
<p>　　<strong>具体导出（ExportStandardHtmlFile等）角色：这个角色实现了抽象导出（ExportFile）角色所声明的接口，工厂方法模式所创建的每一个对象都是某个具体导出角色的实例。</strong></p>
<p>源代码<br>　　首先是抽象工厂角色源代码。它声明了一个工厂方法，要求所有的具体工厂角色都实现这个工厂方法。参数type表示导出的格式是哪一种结构，如：导出HTML格式有两种结构，一种是标准结构，一种是财务需要的结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div></pre></td><td class="code"><pre><div class="line">public interface ExportFactory &#123;</div><div class="line">    public ExportFile factory(<span class="built_in">String</span> type);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//具体工厂角色类源代码：</span></div><div class="line"></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ExportHtmlFactory</span> <span class="title">implements</span> <span class="title">ExportFactory</span></span>&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public ExportFile factory(<span class="built_in">String</span> type) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">if</span>(<span class="string">"standard"</span>.equals(type))&#123;</div><div class="line">            </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExportStandardHtmlFile();</div><div class="line">            </div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"financial"</span>.equals(type))&#123;</div><div class="line">            </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExportFinancialHtmlFile();</div><div class="line">            </div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没有找到对象"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ExportPdfFactory</span> <span class="title">implements</span> <span class="title">ExportFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public ExportFile factory(<span class="built_in">String</span> type) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">if</span>(<span class="string">"standard"</span>.equals(type))&#123;</div><div class="line">            </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExportStandardPdfFile();</div><div class="line">            </div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"financial"</span>.equals(type))&#123;</div><div class="line">            </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExportFinancialPdfFile();</div><div class="line">            </div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没有找到对象"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//抽象导出角色类源代码：</span></div><div class="line"></div><div class="line">public interface ExportFile &#123;</div><div class="line">    public boolean <span class="keyword">export</span>(<span class="built_in">String</span> data);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//具体导出角色类源代码，通常情况下这个类会有复杂的业务逻辑。</span></div><div class="line"></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ExportFinancialHtmlFile</span> <span class="title">implements</span> <span class="title">ExportFile</span></span>&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean <span class="keyword">export</span>(<span class="built_in">String</span> data) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 业务逻辑</div><div class="line">         */</div><div class="line">        System.out.println(<span class="string">"导出财务版HTML文件"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ExportFinancialPdfFile</span> <span class="title">implements</span> <span class="title">ExportFile</span></span>&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean <span class="keyword">export</span>(<span class="built_in">String</span> data) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 业务逻辑</div><div class="line">         */</div><div class="line">        System.out.println(<span class="string">"导出财务版PDF文件"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ExportStandardHtmlFile</span> <span class="title">implements</span> <span class="title">ExportFile</span></span>&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean <span class="keyword">export</span>(<span class="built_in">String</span> data) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 业务逻辑</div><div class="line">         */</div><div class="line">        System.out.println(<span class="string">"导出标准HTML文件"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ExportStandardPdfFile</span> <span class="title">implements</span> <span class="title">ExportFile</span> </span>&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean <span class="keyword">export</span>(<span class="built_in">String</span> data) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 业务逻辑</div><div class="line">         */</div><div class="line">        System.out.println(<span class="string">"导出标准PDF文件"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//客户端角色类源代码：</span></div><div class="line"></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="built_in">String</span> data = <span class="string">""</span>;</div><div class="line">        ExportFactory exportFactory = <span class="keyword">new</span> ExportHtmlFactory();</div><div class="line">        ExportFile ef = exportFactory.factory(<span class="string">"financial"</span>);</div><div class="line">        ef.export(data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2017/04/27/java工厂方法模式/2.jpg" alt="2"></p>
<p>客户端创建ExportHtmlFactory对象，这时客户端所持有变量的静态类型为ExportFactory，而实际类型为ExportHtmlFactory。然后客户端调用ExportHtmlFactory对象的工厂方法factory()，接着后者调用ExportFinancialHtmlFile的构造子创建出导出对象。</p>
<p><strong>工厂方法模式和简单工厂模式</strong><br>　　工厂方法模式和简单工厂模式在结构上的不同很明显。工厂方法模式的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上。<br>　　工厂方法模式退化后可以变得很像简单工厂模式。设想如果非常确定一个系统只需要一个具体工厂类，那么不妨把抽象工厂类合并到具体工厂类中去。由于只有一个具体工厂类，所以不妨将工厂方法改为静态方法，这时候就得到了简单工厂模式。</p>
<p>　　如果系统需要加入一个新的导出类型，那么所需要的就是向系统中加入一个这个导出类以及所对应的工厂类。没有必要修改客户端，也没有必要修改抽象工厂角色或者其他已有的具体工厂角色。对于增加新的导出类型而言，这个系统完全支持“开-闭原则”。
　　</p>
<p><strong>完结</strong><br>　　一个应用系统是由多人开发的，导出的功能是你实现的，但是使用者（调用这个方法的人）可能却是其他人。这时候你应该设计的足够灵活并尽可能降低两者之间的耦合度，当你修改或增加一个新的功能时，使用者不需要修改任何地方。假如你的设计不够灵活，那么将无法面对客户多变的需求。可能一个极小的需求变更，都会使你的代码结构发生改变，并导致其他使用你所提供的接口的人都要修改他们的代码。牵一处而动全身，这就使得日后这个系统将难以维护</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/19/理解java反射机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="m">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="M'S BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/19/理解java反射机制/" itemprop="url">
                  理解java反射机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-19T17:20:15+08:00">
                2017-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、什么是反射？"><a href="#一、什么是反射？" class="headerlink" title="一、什么是反射？"></a>一、什么是反射？</h2><p>反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。<br>Oracle官方对反射的解释是</p>
<blockquote>
<p>Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.<br>The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.</p>
</blockquote>
<p> 简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。<br>程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。<br> 反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p>
<p>Java反射框架主要提供以下功能：</p>
<ol>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li>
<li>在运行时调用任意一个对象的方法<br><strong>重点：是运行时而不是编译时</strong></li>
</ol>
<h2 id="二、反射的用途"><a href="#二、反射的用途" class="headerlink" title="二、反射的用途"></a>二、反射的用途</h2><p>很多人都认为反射在实际的Java开发应用中并不广泛，其实不然。<br> 当我们在使用IDE(如Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。<br> 反射最重要的用途就是开发各种通用框架。<br> 很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。<br> 举一个例子，在运用Struts 2框架的开发中我们一般会在struts.xml里去配置Action，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"login"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.ScZyhSoft.test.action.SimpleLoginAction"</span></div><div class="line">        <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">result</span>&gt;</span>/shop/shop-index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"error"</span>&gt;</span>login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></div></pre></td></tr></table></figure>
<p>配置文件与Action建立了一种映射关系，当View层发出请求时，请求会被StrutsPrepareAndExecuteFilter拦截，然后StrutsPrepareAndExecuteFilter会去动态地创建Action实例。<br>——比如我们请求login.action，那么StrutsPrepareAndE2xecuteFilter就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。<br>对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。</p>
<h2 id="三、反射的基本运用"><a href="#三、反射的基本运用" class="headerlink" title="三、反射的基本运用"></a>三、反射的基本运用</h2><p>上面我们提到了反射可以用于判断任意对象所属的类，获得Class对象，构造任意一个对象以及调用一个对象。这里我们介绍一下基本反射功能的实现(反射相关的类一般都在java.lang.relfect包里)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1、获得Class对象，方法有三种</span></div><div class="line"><span class="comment">//(1)使用Class类的forName静态方法:</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className);</div><div class="line"><span class="comment">//在JDBC开发中常用此方法加载数据库驱动:</span></div><div class="line">Class.forName(driver);</div><div class="line"></div><div class="line"><span class="comment">//(2)直接获取某一个对象的class，比如:</span></div><div class="line"></div><div class="line">Class&lt;?&gt; klass = <span class="keyword">int</span>.class;</div><div class="line">Class&lt;?&gt; classInt = Integer.TYPE;</div><div class="line"></div><div class="line"><span class="comment">//(3)调用某个对象的getClass()方法,比如:</span></div><div class="line"></div><div class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</div><div class="line">Class&lt;?&gt; klass = str.getClass();</div><div class="line"></div><div class="line"><span class="comment">//2、判断是否为某个类的实例</span></div><div class="line"><span class="comment">//一般地，我们用instanceof关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断是否为某个类的实例，它是一个Native方法：</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//3、创建实例</span></div><div class="line"><span class="comment">//通过反射来生成对象主要有两种方式。</span></div><div class="line"><span class="comment">//（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。</span></div><div class="line"></div><div class="line">Class&lt;?&gt; c = String.class;</div><div class="line">Object str = c.newInstance();</div><div class="line"></div><div class="line"><span class="comment">//（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。</span></div><div class="line"></div><div class="line"><span class="comment">//获取String所对应的Class对象</span></div><div class="line">Class&lt;?&gt; c = String.class;</div><div class="line"></div><div class="line"><span class="comment">//获取String类带一个String参数的构造器</span></div><div class="line">Constructor constructor = c.getConstructor(String.class);</div><div class="line"></div><div class="line"><span class="comment">//根据构造器创建实例</span></div><div class="line">Object obj = constructor.newInstance(<span class="string">"23333"</span>);</div><div class="line">System.out.println(obj);</div><div class="line"></div><div class="line"><span class="comment">//4、获取方法</span></div><div class="line"><span class="comment">//获取某个Class对象的方法集合，主要有以下几个方法：</span></div><div class="line"><span class="comment">//getDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException</div><div class="line"><span class="comment">//getMethods()方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> Method[] getMethods() <span class="keyword">throws</span> SecurityException</div><div class="line"><span class="comment">//getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></div><div class="line"><span class="comment">//只是这样描述的话可能难以理解，我们用例子来理解这三个方法：</span></div><div class="line"></div><div class="line"><span class="keyword">package</span> org.ScZyhSoft.common;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</div><div class="line">	        Class&lt;?&gt; c = methodClass.class;</div><div class="line">	        Object object = c.newInstance();</div><div class="line">	        Method[] methods = c.getMethods();</div><div class="line">	        Method[] declaredMethods = c.getDeclaredMethods();</div><div class="line">	        <span class="comment">//获取methodClass类的add方法</span></div><div class="line">	        Method method = c.getMethod(<span class="string">"add"</span>, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</div><div class="line">	        <span class="comment">//getMethods()方法获取的所有方法</span></div><div class="line">	        System.out.println(<span class="string">"getMethods获取的方法："</span>);</div><div class="line">	        <span class="keyword">for</span>(Method m:methods)</div><div class="line">	            System.out.println(m);</div><div class="line">	        <span class="comment">//getDeclaredMethods()方法获取的所有方法</span></div><div class="line">	        System.out.println(<span class="string">"getDeclaredMethods获取的方法："</span>);</div><div class="line">	        <span class="keyword">for</span>(Method m:declaredMethods)</div><div class="line">	            System.out.println(m);</div><div class="line">	    &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">methodClass</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> fuck = <span class="number">3</span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> a+b;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> a+b;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//程序运行的结果如下:</span></div><div class="line"><span class="comment">//getMethods获取的方法：</span></div><div class="line"><span class="comment">//public int org.ScZyhSoft.common.methodClass.add(int,int)</span></div><div class="line"><span class="comment">//public int org.ScZyhSoft.common.methodClass.sub(int,int)</span></div><div class="line"><span class="comment">//public final void java.lang.Object.wait() throws java.lang.InterruptedException</span></div><div class="line"><span class="comment">//public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span></div><div class="line"><span class="comment">//public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span></div><div class="line"><span class="comment">//public boolean java.lang.Object.equals(java.lang.Object)</span></div><div class="line"><span class="comment">//public java.lang.String java.lang.Object.toString()</span></div><div class="line"><span class="comment">//public native int java.lang.Object.hashCode()</span></div><div class="line"><span class="comment">//public final native java.lang.Class java.lang.Object.getClass()</span></div><div class="line"><span class="comment">//public final native void java.lang.Object.notify()</span></div><div class="line"><span class="comment">//public final native void java.lang.Object.notifyAll()</span></div><div class="line"><span class="comment">//getDeclaredMethods获取的方法：</span></div><div class="line"><span class="comment">//public int org.ScZyhSoft.common.methodClass.add(int,int)</span></div><div class="line"><span class="comment">//public int org.ScZyhSoft.common.methodClass.sub(int,int)</span></div><div class="line"><span class="comment">//可以看到，通过getMethods()获取的方法可以获取到父类的方法,比如java.lang.Object下定义的各个方法。</span></div><div class="line"></div><div class="line"><span class="comment">//5、获取构造器信息</span></div><div class="line"><span class="comment">//获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建//一个对象实例:</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></div><div class="line"><span class="comment">//此方法可以根据传入的参数来调用对应的Constructor创建对象实例~</span></div><div class="line"></div><div class="line"><span class="comment">//6、获取类的成员变量（字段）信息</span></div><div class="line"><span class="comment">//主要是这几个方法，在此不再赘述：</span></div><div class="line"><span class="comment">//getFiled: 访问公有的成员变量</span></div><div class="line"><span class="comment">//getDeclaredField：所有已声明的成员变量。但不能得到其父类的成员变量</span></div><div class="line"><span class="comment">//getFileds和getDeclaredFields用法同上（参照Method）</span></div><div class="line"></div><div class="line"><span class="comment">//7、调用方法</span></div><div class="line"><span class="comment">//当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。invoke方法的原型为:</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></div><div class="line">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</div><div class="line">           InvocationTargetException</div><div class="line"><span class="comment">//下面是一个实例：</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> class test1 &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</div><div class="line">        Class&lt;?&gt; klass = methodClass.class;</div><div class="line">        <span class="comment">//创建methodClass的实例</span></div><div class="line">        Object obj = klass.newInstance();</div><div class="line">        <span class="comment">//获取methodClass类的add方法</span></div><div class="line">        Method method = klass.getMethod(<span class="string">"add"</span>,<span class="keyword">int</span>.class,<span class="keyword">int</span>.class);</div><div class="line">        <span class="comment">//调用method对应的方法 =&gt; add(1,4)</span></div><div class="line">        Object result = method.invoke(obj,<span class="number">1</span>,<span class="number">4</span>);</div><div class="line">        System.out.println(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">methodClass</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> fuck = <span class="number">3</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a+b;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a+b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//关于invoke()方法的详解，后面我会专门写一篇文章来深入解析invoke的过程。</span></div><div class="line"></div><div class="line"><span class="comment">//8、利用反射创建数组</span></div><div class="line"><span class="comment">//数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。下面我们看一看利用反射创建数组的例子：</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testArray</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</div><div class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"java.lang.String"</span>);</div><div class="line">        Object array = Array.newInstance(cls,<span class="number">25</span>);</div><div class="line">        <span class="comment">//往数组里添加内容</span></div><div class="line">        Array.set(array,<span class="number">0</span>,<span class="string">"hello"</span>);</div><div class="line">        Array.set(array,<span class="number">1</span>,<span class="string">"Java"</span>);</div><div class="line">        Array.set(array,<span class="number">2</span>,<span class="string">"fuck"</span>);</div><div class="line">        Array.set(array,<span class="number">3</span>,<span class="string">"Scala"</span>);</div><div class="line">        Array.set(array,<span class="number">4</span>,<span class="string">"Clojure"</span>);</div><div class="line">        <span class="comment">//获取某一项的内容</span></div><div class="line">        System.out.println(Array.get(array,<span class="number">3</span>));</div><div class="line">    &#125;</div><div class="line"><span class="comment">//其中的Array类为java.lang.reflect.Array类。我们通过Array.newInstance()创建数组对象，它的原型是:</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span></span></div><div class="line">        <span class="keyword">throws</span> NegativeArraySizeException &#123;</div><div class="line">        <span class="keyword">return</span> newArray(componentType, length);</div><div class="line">    &#125;</div><div class="line"><span class="comment">//而newArray()方法是一个Native方法，它在Hotspot JVM里的具体实现我们后边再研究，这里先把源码贴出来</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">newArray</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span></span></div><div class="line">        <span class="keyword">throws</span> NegativeArraySizeException;</div><div class="line"><span class="comment">//源码目录:openjdk\hotspot\src\share\vm\runtime\reflection.cpp</span></div><div class="line"></div><div class="line">arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) &#123;</div><div class="line">  <span class="keyword">if</span> (element_mirror == NULL) &#123;</div><div class="line">    THROW_0(vmSymbols::java_lang_NullPointerException());</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (length &lt; <span class="number">0</span>) &#123;</div><div class="line">    THROW_0(vmSymbols::java_lang_NegativeArraySizeException());</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (java_lang_Class::is_primitive(element_mirror)) &#123;</div><div class="line">    Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);</div><div class="line">    <span class="keyword">return</span> TypeArrayKlass::cast(tak)-&gt;allocate(length, THREAD);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    Klass* k = java_lang_Class::as_Klass(element_mirror);</div><div class="line">    <span class="keyword">if</span> (k-&gt;oop_is_array() &amp;&amp; ArrayKlass::cast(k)-&gt;dimension() &gt;= MAX_DIM) &#123;</div><div class="line">      THROW_0(vmSymbols::java_lang_IllegalArgumentException());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> oopFactory::new_objArray(k, length, THREAD);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//另外，Array类的set()和get()方法都为Native方法，在HotSpot JVM里分别对应Reflection::array_set和Reflection::array_get方法，这里就不详细解析了。</span></div><div class="line"></div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/18/深入理解abstract-class和interface/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="m">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="M'S BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/18/深入理解abstract-class和interface/" itemprop="url">
                  深入理解abstract class和interface
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-18T17:13:18+08:00">
                2017-04-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/18/java装饰模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="m">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="M'S BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/18/java装饰模式/" itemprop="url">
                  java装饰模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-18T16:46:30+08:00">
                2017-04-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>在一个项目中，你会有非常多的因素考虑不到，特别是业务的变更，不时的冒出一个需求是很正常的情况。有三个继承关系的类：Father、Son、GrandSon，我们要在Son类上增强一些功能怎么办？给Son类增加方法吗？那对GrandSon的影响呢？特别是对GrandSon有多个的情况，你会怎么办？认真看完本文，你会找到你的答案。<br>JavaIO中，像下面的嵌套语句是不是很常见，为什么要怎样定义呢？理解装饰模式后，你会找到答案。<br>DataInputStream in = new DataInputStream(new BufferedInputStream(new FileInputStream(“FileTest.Java”)));</p>
<h2 id="2-《设计模式之禅》中的例子"><a href="#2-《设计模式之禅》中的例子" class="headerlink" title="2 《设计模式之禅》中的例子"></a>2 《设计模式之禅》中的例子</h2><p>成绩单需要父母签名这事很多人都经历过，这举这样一个例子：</p>
<p><img src="/2017/04/18/java装饰模式/1.jpg" alt="1"></p>
<p>代码清单1 抽象成绩单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//抽象成绩单  </span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SchoolReport</span> </span>&#123;  </div><div class="line">    <span class="comment">//展示成绩情况  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span></span>;  </div><div class="line">    <span class="comment">//家长签字  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sign</span><span class="params">(String name)</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码清单2 四年级成绩单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//四年级成绩单  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FouthGradeSchoolReport</span> <span class="keyword">extends</span> <span class="title">SchoolReport</span></span>&#123;  </div><div class="line">    <span class="comment">//我的成绩单  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="comment">//成绩单的格式是这个样子的  </span></div><div class="line">        System.out.println(<span class="string">"尊敬的XXX家长："</span>);  </div><div class="line">        System.out.println(<span class="string">"······"</span>);  </div><div class="line">        System.out.println(<span class="string">"语文62 数学65 体育98 自然63"</span>);  </div><div class="line">        System.out.println(<span class="string">"······"</span>);  </div><div class="line">        System.out.println(<span class="string">"      家长签字"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//家长签名  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sign</span><span class="params">(String name)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"家长签字为："</span> + name);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码清单3 老爸查看成绩单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//老爸查看成绩单  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="comment">//把成绩单拿过来  </span></div><div class="line">        SchoolReport sr = <span class="keyword">new</span> FouthGradeSchoolReport();  </div><div class="line">        <span class="comment">//看成绩单  </span></div><div class="line">        sr.report();  </div><div class="line">        <span class="comment">//签名？ 休想！  </span></div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">/*Output: </span></div><div class="line">尊敬的XXX家长： </div><div class="line">······ </div><div class="line">语文62 数学65 体育98 自然63 </div><div class="line">······ </div><div class="line">      家长签字 </div><div class="line"> */  </div></pre></td></tr></table></figure>
<p>就这成绩还要我签字？！老爸就开始找扫帚，我开始做准备：深呼吸，绷紧肌肉，提臀，收腹。 哈哈，幸运的是，这个不是当时的真实情况，我没有直接把成绩单交给老爸，而是在交给他之前做了点技术工作，我要把成绩单封装一下，封装分类两步来实现， 如下所示。<br>● 汇报最高成绩<br>跟老爸说各个科目的最高分，语文最高是75，数学是78，自然是80，然后老爸觉得我的成绩与最高分数相差不多，考的还是不错的嘛！这个是实情，但是不知道是什么原因，反正期末考试都考得不怎么样，但是基本上都集中在70分以上，我这60多分基本上还是垫底的角色。<br>● 汇报排名情况<br>在老爸看完成绩单后，告诉他我在全班排第38名，这个也是实情，为啥呢？有将近十个同学退学了！ 这个情况我是不会说的。 不知道是不是当时第一次发成绩单时学校没有考虑清楚，没有写上总共有多少同学，排第几名，反正是被我钻了个空子。<br>那修饰是说完了，我们看看类图如何修改，如下图所示：</p>
<p><img src="/2017/04/18/java装饰模式/2.jpg" alt="2"></p>
<p>代码清单4 修饰成绩单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//修饰成绩单  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SugarFouthGradeSchoolReport</span> <span class="keyword">extends</span> <span class="title">FouthGradeSchoolReport</span> </span>&#123;  </div><div class="line">    <span class="comment">// 首先要定义你要美化的方法， 先给老爸说学校最高成绩  </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportHighScore</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"这次考试语文最高是75， 数学是78， 自然是80"</span>);  </div><div class="line">    &#125;<span class="comment">// 在老爸看完毕成绩单后，我再汇报学校的排名情况  </span></div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportSort</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"我是排名第38名..."</span>);  </div><div class="line">    &#125;<span class="comment">// 由于汇报的内容已经发生变更，那所以要重写父类  </span></div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.reportHighScore(); <span class="comment">// 先说最高成绩  </span></div><div class="line">        <span class="keyword">super</span>.report(); <span class="comment">// 然后老爸看成绩单  </span></div><div class="line">        <span class="keyword">this</span>.reportSort(); <span class="comment">// 然后告诉老爸学习学校排名  </span></div><div class="line">    &#125;  </div><div class="line">&#125;  </div></pre></td></tr></table></figure>
<p>代码清单5 老爸查看修饰后的成绩单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father2</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="comment">// 把美化过的成绩单拿过来  </span></div><div class="line">        SchoolReport sr = <span class="keyword">new</span> SugarFouthGradeSchoolReport();  </div><div class="line">        <span class="comment">// 看成绩单  </span></div><div class="line">        sr.report();  </div><div class="line">        <span class="comment">// 然后老爸， 一看， 很开心， 就签名了  </span></div><div class="line">        sr.sign(<span class="string">"老三"</span>); <span class="comment">// 我叫小三， 老爸当然叫老三  </span></div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">/* </span></div><div class="line">这次考试语文最高是75， 数学是78， 自然是80 </div><div class="line">尊敬的XXX家长： </div><div class="line">······ </div><div class="line">语文62 数学65 体育98 自然63 </div><div class="line">······ </div><div class="line">      家长签字 </div><div class="line">我是排名第38名... </div><div class="line">家长签字为：老三 </div><div class="line"> * */ </div></pre></td></tr></table></figure>
<p>通过继承确实能够解决这个问题，老爸看成绩单很开心，然后就给签字了，但现实的情况是很复杂的，可能老爸听我汇报最高成绩后，就直接乐开花了，直接签名了，后面的排名就没必要看了，或者老爸要先看排名情况，那怎么办？ 继续扩展？你能扩展多少个类？这还是一个比较简单的场景，一旦需要装饰的条件非常多，比如20个，你还通过继承来解决，你想象的子类有多少个？ 你是不是马上就要崩溃了！<br>好，你也看到通过继承情况确实出现了问题，类爆炸，类的数量激增，光写这些类不累死你才怪，而且还要想想以后维护怎么办，谁愿意接收这么一大摊本质相似的代码维护工作？并且在面向对象的设计中，如果超过两层继承，你就应该想想是不是出设计问题了，是不是应该重新找一条康庄大道了，这是经验值，不是什么绝对的，继承层次越多以后的维护成本越多，问题这么多，那怎么办？好办，我们定义一批专门负责装饰的类，然后根据实际情况来决定是否需要进行装饰，类图稍做修正，如图17-4所示。</p>
<p><img src="/2017/04/18/java装饰模式/3.jpg" alt="3"></p>
<p>增加一个抽象类和两个实现类，其中Decorator的作用是封装SchoolReport类，如果大家还记得代理模式，那么很容易看懂这个类图，装饰类的作用也就是一个特殊的代理类，真实的执行者还是被代理的角色FouthGradeSchoolReport。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 抽象类，也是最核心的顶层对象</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SchoolReport</span> </span>&#123;</div><div class="line">    <span class="comment">// 报告成绩</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 家长签字</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sign</span><span class="params">(String name)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 最核心、最原始、最基本的接口或抽象类的实现，你要装饰的就是它</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreateSchoolReport</span> <span class="keyword">extends</span> <span class="title">SchoolReport</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"报告家长，您的孩子成绩不及格"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sign</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"家长签名："</span> + name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 装饰的抽象类，这是一个特殊的代理类（代理模式），具体执行的方法还是由传入进来的SchoolReport(具体实现类)决定</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">SchoolReport</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> SchoolReport schoolReport;</div><div class="line"></div><div class="line">    <span class="comment">// 构造函数，传递SchoolReport对象并保存在私有属性中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(SchoolReport schoolReport)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.schoolReport = schoolReport;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 具体执行的report方法由传进来的SchoolReport决定</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.schoolReport.report();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sign</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.schoolReport.sign(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 具体的装饰类，就是由他进行对象的装饰</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighScoreDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 由于父类显示的定义了构造方法，这里也必须显示定义</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HighScoreDecorator</span><span class="params">(SchoolReport schoolReport)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(schoolReport);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 自定义的修饰方法，此方法用于修饰具体的SchoolReport对象ConcreateSchoolReport</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">highCore</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"其实大家都不及格，你儿子分算高的"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//重写report方法，将自定义方法放在父类的report方法执行之前执行，用于修饰</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123;</div><div class="line">        highCore();</div><div class="line">        <span class="keyword">super</span>.report();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderSchoolReport</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 由于父类显示的定义了构造方法，这里也必须显示定义</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderSchoolReport</span><span class="params">(SchoolReport schoolReport)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(schoolReport);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 自定义的修饰方法，此方法用于修饰具体的SchoolReport对象ConcreateSchoolReport</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">order</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"而且你儿子的分数排名全班第一"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//重写report方法，将自定义方法放在父类的report方法执行之前执行，用于修饰</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123;</div><div class="line">        order();</div><div class="line">        <span class="keyword">super</span>.report();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 客户端调用</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SchoolReport report = <span class="keyword">new</span> ConcreateSchoolReport();</div><div class="line">        report = <span class="keyword">new</span> HighScoreDecorator(report);</div><div class="line">        report = <span class="keyword">new</span> OrderSchoolReport(report);</div><div class="line">        report.report();</div><div class="line">        report.sign(<span class="string">"NB"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-装饰模式的定义"><a href="#3-装饰模式的定义" class="headerlink" title="3 装饰模式的定义"></a>3 装饰模式的定义</h2><p>装饰模式（Decorator Pattern）是一种比较常见的模式，其定义如下：Attach additionalresponsibilities to an object dynamically keeping the same interface.Decoratorsprovide a flexible alternative to subclassing for extending functionality.（ 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。）<br>装饰模式的通用类图如图5所示。</p>
<p><img src="/2017/04/18/java装饰模式/4.jpg" alt="4"></p>
<p>在类图中，有四个角色需要说明：<br><strong>● Component抽象构件</strong><br>Component是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象，如上面的成绩单。<br>注意 在装饰模式中，必然有一个最基本、最核心、最原始的接口或抽象类充当Component抽象构件。<br><strong>● ConcreteComponent 具体构件</strong><br>ConcreteComponent是最核心、最原始、最基本的接口或抽象类的实现，你要装饰的就是它。<br><strong>● Decorator装饰角色</strong><br>一般是一个抽象类，做什么用呢？实现接口或者抽象方法，它里面可不一定有抽象的方法呀，在它的属性里必然有一个private变量指向Component抽象构件。<br><strong>● 具体装饰角色</strong><br>ConcreteDecoratorA和ConcreteDecoratorB是两个具体的装饰类，你要把你最核心的、最原始的、最基本的东西装饰成其他东西，上面的例子就是把一个比较平庸的成绩单装饰成家长认可的成绩单。</p>
<p>理解client中的new</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//这里创建了一个ConcreateComponent对象，返回对象的引用component</span></div><div class="line">        Component component = <span class="keyword">new</span> ConcreateComponent();</div><div class="line"></div><div class="line">        <span class="comment">//这里将上述对象传入ConcreateDecoratorA中，通过其构造方法将component传入到Decorato中</span></div><div class="line">        <span class="comment">//对象：一个Decorato对象，其中私有属性component保存为ConcreateComponent</span></div><div class="line">        <span class="comment">//     一个ConcreateDecoratorA对象component</span></div><div class="line">        component = <span class="keyword">new</span> ConcreateDecoratorA(component);</div><div class="line"></div><div class="line">        <span class="comment">//这里将ConcreateDecoratorA传入ConcreateDecoratorB中，通过其构造方法将其传入到Decorato中</span></div><div class="line">        <span class="comment">//对象：一个Decorato对象，其中私有属性component保存为ConcreateDecoratorA</span></div><div class="line">        <span class="comment">//     一个ConcreateDecoratorB对象component</span></div><div class="line">        component = <span class="keyword">new</span> ConcreateDecoratorB(component);</div><div class="line"></div><div class="line">        <span class="comment">//先执行ConcreateDecoratorB中的operate方法，再执行其父类Decorato中的operate，注意此时的Decorato方法operate会调用ConcreateDecoratorA中的operate，</span></div><div class="line">        <span class="comment">//该方法又会调用ConcreateComponent中的operate方法，故只需要在ConcreateDecoratorA、B两个修饰类的operate中加上具体修饰的方法即可完成链式的调用</span></div><div class="line">        component.operate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-半透明的装饰模式"><a href="#4-半透明的装饰模式" class="headerlink" title="4 半透明的装饰模式"></a>4 半透明的装饰模式</h2><h3 id="4-1-装饰模式的简化"><a href="#4-1-装饰模式的简化" class="headerlink" title="4.1 装饰模式的简化"></a>4.1 装饰模式的简化</h3><p>如果只有一个ConcreteComponent类，那么可以考虑去掉抽象的Component类（接口），把Decorator作为一个ConcreteComponent子类。如下图所示：</p>
<p><img src="/2017/04/18/java装饰模式/5.jpg" alt="5"></p>
<p>如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。甚至在只有两个ConcreteDecorator类的情况下，都可以这样做。如下图所示</p>
<p><img src="/2017/04/18/java装饰模式/6.jpg" alt="6"></p>
<h3 id="4-2-透明性的要求"><a href="#4-2-透明性的要求" class="headerlink" title="4.2 透明性的要求"></a>4.2 透明性的要求</h3><p>装饰模式对客户端的透明性要求程序不要声明一个ConcreteComponent类型的变量，而应当声明一个Component类型的变量。<br>用上面成绩单的例子来说有：<br>SchoolReport sr;<br>sr = new FouthGradeSchoolReport();<br>sr = new HighScoreDecorator(sr);<br>sr = new SortDecorator(sr);<br>而下面的做法是不对的：<br>HighScoreDecorator hd = new HighScoreDecorator(sr);<br>SortDecorator sd = new SortDecorator(sr);</p>
<h3 id="4-3-半透明的装饰模式"><a href="#4-3-半透明的装饰模式" class="headerlink" title="4.3 半透明的装饰模式"></a>4.3 半透明的装饰模式</h3><p>然而，纯粹的装饰模式很难找到。装饰模式的用意是在不改变接口的前提下，增强所考虑的类的性能。在增强性能的时候，往往需要建立新的公开的方法。上面成绩单的例子中，显示前十名学生信息。这就意味着SortDecorator类中应当有一个新的displayTopTen()方法。再比如，显示显示各科最高分学生信息，这就意味着在HighScoreDecorator类里应当有一个新的showTop()方法。<br>这就导致了大多数的装饰模式的实现都是“半透明”的，而不是完全透明的。换言之，允许装饰模式改变接口，增加新的方法。这意味着客户端可以声明ConcreteDecorator类型的变量，从而可以调用ConcreteDecorator类中才有的方法：<br>SchoolReport sr = new SortDecorator();<br>SortDecorator sd = new SortDecorator();<br>sd.displayTopTen();<br>半透明的装饰模式是介于装饰模式和适配器模式之间的。适配器模式的用意是改变所考虑的类的接口，也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能。大多数的装饰模式实际上是半透明的装饰模式，这样的装饰模式也称做半装饰、半适配器模式。<br>装饰模式和适配器模式都是“包装模式(Wrapper Pattern)”，它们都是通过封装其他对象达到设计的目的的，但是它们的形态有很大区别。<br>理想的装饰模式在对被装饰对象进行功能增强的同时，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。而适配器模式则不然，一般而言，适配器模式并不要求对源对象的功能进行增强，但是会改变源对象的接口，以便和目标接口相符合。<br>装饰模式有透明和半透明两种，这两种的区别就在于装饰角色的接口与抽象构件角色的接口是否完全一致。透明的装饰模式也就是理想的装饰模式，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。相反，如果装饰角色的接口与抽象构件角色接口不一致，也就是说装饰角色的接口比抽象构件角色的接口宽的话，装饰角色实际上已经成了一个适配器角色，这种装饰模式也是可以接受的，称为“半透明”的装饰模式，如下图所示。</p>
<p><img src="/2017/04/18/java装饰模式/7.jpg" alt="7"></p>
<p>在适配器模式里面，适配器类的接口通常会与目标类的接口重叠，但往往并不完全相同。换言之，适配器类的接口会比被装饰的目标类接口宽。<br>显然，半透明的装饰模式实际上就是处于适配器模式与装饰模式之间的灰色地带。如果将装饰模式与适配器模式合并成为一个“包装模式”的话，那么半透明的装饰模式倒可以成为这种合并后的“包装模式”的代表。</p>
<h2 id="5-装饰模式应用"><a href="#5-装饰模式应用" class="headerlink" title="5 装饰模式应用"></a>5 装饰模式应用</h2><h3 id="5-1-装饰模式的优点"><a href="#5-1-装饰模式的优点" class="headerlink" title="5.1 装饰模式的优点"></a>5.1 装饰模式的优点</h3><ul>
<li>装饰类和被装饰类可以独立发展，而不会相互耦合。换句话说，Component类无须知道Decorator类，Decorator类是从外部来扩展Component类的功能，而Decorator也不用知道具体的构件。</li>
<li>装饰模式是继承关系的一个替代方案。我们看装饰类Decorator，不管装饰多少层，返回的对象还是Component，实现的还是is-a的关系。</li>
<li>装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者除掉一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。</li>
<li>过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。<h3 id="5-2-装饰模式的缺点"><a href="#5-2-装饰模式的缺点" class="headerlink" title="5.2 装饰模式的缺点"></a>5.2 装饰模式的缺点</h3></li>
<li>由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是，在另一方面，使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。</li>
<li>多层的装饰是比较复杂的。<h3 id="5-3-装饰模式的使用场景"><a href="#5-3-装饰模式的使用场景" class="headerlink" title="5.3 装饰模式的使用场景"></a>5.3 装饰模式的使用场景</h3></li>
<li>需要扩展一个类的功能，或给一个类增加附加功能。</li>
<li>需要动态地给一个对象增加功能，这些功能可以再动态地撤销。</li>
<li>需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式。</li>
<li>装饰模式在Java语言中的最著名的应用：Java I/O标准库的设计了</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/17/java策略模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="m">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="M'S BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/17/java策略模式/" itemprop="url">
                  java策略模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-17T10:02:12+08:00">
                2017-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在阎宏博士的《Java与模式》一书中开头是这样描述策略（Strategy）模式的：</p>
<p><strong>策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。</strong></p>
<h2 id="策略模式的结构"><a href="#策略模式的结构" class="headerlink" title="策略模式的结构"></a>策略模式的结构</h2><p>　　策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。下面就以一个示意性的实现讲解策略模式实例的结构。</p>
<p>　　这个模式涉及到三个角色：</p>
<ul>
<li><p><strong>环境(Context)角色</strong>：持有一个Strategy的引用。</p>
</li>
<li><p><strong>抽象策略(Strategy)角色</strong>：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</p>
</li>
<li><p><strong>具体策略(ConcreteStrategy)角色</strong>：包装了相关的算法或行为。</p>
</li>
</ul>
<h3 id="环境角色类"><a href="#环境角色类" class="headerlink" title="环境角色类"></a>环境角色类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 环境角色，持有Strategy的引用</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyContext</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Strategy strategy;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造函数传入具体的Strategy实现类</div><div class="line">     * <span class="doctag">@param</span> strategy</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StrategyContext</span><span class="params">(Strategy strategy)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.strategy = strategy;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 策略方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDo</span><span class="params">()</span></span>&#123;</div><div class="line">        strategy.doMath();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="抽象策略类"><a href="#抽象策略类" class="headerlink" title="抽象策略类"></a>抽象策略类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 抽象的策略类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 抽象的侧路方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doMath</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="具体策略类"><a href="#具体策略类" class="headerlink" title="具体策略类"></a>具体策略类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 完成具体的算法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doMath</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"doAdd"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategySub</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 完成具体的算法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doMath</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"doSub"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//客户端需要知道具体的策略类，这意味着客户端需要知道所有的策略方法以及他们之间的区别</span></div><div class="line">        ConcreteStrategyAdd add = <span class="keyword">new</span> ConcreteStrategyAdd();</div><div class="line">        StrategyContext context = <span class="keyword">new</span> StrategyContext(add);</div><div class="line">        context.contextDo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的示例可以看出，策略模式仅仅封装算法，提供新的算法插入到已有系统中，以及老算法从系统中“退休”的方法，策略模式并不决定在何时使用何种算法。在什么情况下使用什么算法是由客户端决定的。</p>
<h2 id="认识策略模式"><a href="#认识策略模式" class="headerlink" title="认识策略模式"></a>认识策略模式</h2><p>　　<strong>策略模式的重心</strong></p>
<p>　　策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。</p>
<p>　　<strong>算法的平等性</strong></p>
<p>　　策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。</p>
<p>　　所以可以这样描述这一系列策略算法：<strong>策略算法是相同行为的不同实现。</strong></p>
<p>　　<strong>运行时策略的唯一性</strong></p>
<p>　　运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。</p>
<p>　　<strong>公有的行为</strong></p>
<p>　　经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。</p>
<p>　　这其实也是典型的将代码向继承等级结构的上方集中的标准做法。</p>
<h2 id="策略模式的优点"><a href="#策略模式的优点" class="headerlink" title="策略模式的优点"></a>策略模式的优点</h2><p>　　（1）策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</p>
<p>　　（2）使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。</p>
<h2 id="策略模式的缺点"><a href="#策略模式的缺点" class="headerlink" title="策略模式的缺点"></a>策略模式的缺点</h2><p>　　（1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</p>
<p>　　（2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</p>
<p>　　（3）将简单工厂与策略模式相结合，将客户端创建策略转移到工厂中，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//客户端需要知道具体的策略类，这意味着客户端需要知道所有的策略方法以及他们之间的区别</span></div><div class="line"><span class="comment">//        ConcreteStrategyAdd add = new ConcreteStrategyAdd();</span></div><div class="line"><span class="comment">//        StrategyContext context = new StrategyContext(add);</span></div><div class="line"><span class="comment">//        context.contextDo();</span></div><div class="line"></div><div class="line">        <span class="comment">//简单工厂模式和策略模式相结合，将创建具体策略的任务交给工厂，客户端只需要知道StrategyContextFactory这个类</span></div><div class="line">        StrategyContextFactory f = <span class="keyword">new</span> StrategyContextFactory(<span class="string">"add"</span>);</div><div class="line">        f.contextDo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyContextFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Strategy strategy;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StrategyContextFactory</span><span class="params">(String type)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (type.equals(<span class="string">"add"</span>)) &#123;</div><div class="line">            <span class="keyword">this</span>.strategy = <span class="keyword">new</span> ConcreteStrategyAdd();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"sub"</span>)) &#123;</div><div class="line">            <span class="keyword">this</span>.strategy = <span class="keyword">new</span> ConcreteStrategySub();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDo</span><span class="params">()</span></span>&#123;</div><div class="line">        strategy.doMath();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/13/js实现观察者模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="m">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="M'S BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/13/js实现观察者模式/" itemprop="url">
                  js实现观察者模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-13T17:22:21+08:00">
                2017-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>js实现观察者模式<br>　　观察者模式：设计该模式背后的主要动力是促进形成松散耦合。在这种模式中，并不是一个对象调用另一个对象的方法，而是一个对象订阅另一个对象的特定活动并在状态改变后获得通知。订阅者也称为观察者，而补观察的对象称为发布者或主题。当发生了一个重要的事件时，发布者将会通知（调用）所有订阅者并且可能经常以事件对象的形式传递消息。</p>
<p>　　思路:发布者对象需要一个数组类型的属性，以存储所有的订阅者。订阅（即注册）行为就是将新的订阅者加入到这个数组中去，则注销即是从这个数组中删除某个订阅者。此外，发布消息，就是循环遍历订阅者列表并通知他们。</p>
<p>　　</p>
<p>　　这里我的大体思路是对的，但是在发布者之外定义了一个新的类即订阅者。在订阅者中定义了一个方法getNews以便在发布者发布消息时调用该方法。然后面试官说这样太麻烦了，万一订阅者没有这个方法呢？然后我不是很懂……于是在发布消息时直接传递了参数：obj.news = msg; 然后面试官说这样不是更麻烦了吗？这样的话如果订阅者没有news这个属性怎么办？还得判断订阅者是否有news这个属性，没有的话就会出现undifined的报错。然后我就不知道该怎么做了……然后面试官为人特别nice，告诉我说可以用继承，或者是在注册时候就传入一个function。</p>
<p>下来后上网查相关，注意点如下：</p>
<ol>
<li><p>发送消息即通知，意味着调用订阅者对象的某个方法。故当用户订阅信息时，该订阅者需要向paper的subscribe()提供它的其中一个方法。——–这应该就是面试官所说的注册时候就传入一个方法。</p>
</li>
<li><p>发布对象paper需要具有以下成员：</p>
</li>
</ol>
<p>　　　　a、 subscribers：一个数组，存储订阅者</p>
<p>　　　　b、 subscribe()：注册/订阅，将订阅者添加到subscribers数组中</p>
<p>　　　　c、 unsubscribe()： 取消订阅。从subscribers数组中删除订阅者</p>
<p>　　　　d、 publish() 循环遍历subscribers数组中的每一个元素，并且调用他们注册时所提供的方法</p>
<p>　　　　所有这三种方法都需要一个type参数，因为发布者可能触发多个事件（比如同时发布一本杂志和一份报纸）而用户可能仅选择订阅其中一种，而不是另外一种。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//由于这些成员对于任何发布者对象都是通用的，故将它们作为独立对象的一个部分来实现是很有意义的。那样我们可将其复制到任何对象中，并将任意给定对象变成一个发布者。</span></div><div class="line"></div><div class="line"><span class="comment">//如下实现一个通用发布者</span></div><div class="line"></div><div class="line"><span class="comment">//定义发布者对象...&#123;&#125;是定义一个对象</span></div><div class="line"><span class="keyword">var</span> publisher = &#123;</div><div class="line">    <span class="attr">subscribers</span>: &#123;</div><div class="line">        <span class="attr">any</span>: []         <span class="comment">//event type: subscribers</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">subscribe</span>: <span class="function"><span class="keyword">function</span>(<span class="params">fn,type</span>)</span>&#123;</div><div class="line">        type = type || <span class="string">'any'</span>;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.subscribers[type] === <span class="string">"undefined"</span>)&#123;</div><div class="line">            <span class="keyword">this</span>.subscribers[type] = [];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.subscribers[type].push(fn);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">unsubscribe</span>: <span class="function"><span class="keyword">function</span>(<span class="params">fn,type</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.visitSubscribers(<span class="string">'unsubscribe'</span>, fn, type);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">publish</span>: <span class="function"><span class="keyword">function</span>(<span class="params">publication, type</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.visitSubscribers(<span class="string">'publish'</span>,publication,type);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">visitSubscribers</span>:<span class="function"><span class="keyword">function</span>(<span class="params">action,arg,type</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> pubtype = type ||<span class="string">'any'</span>,</div><div class="line">            subscribers = <span class="keyword">this</span>.subscribers[pubtype],</div><div class="line">            i,</div><div class="line">            max = subscribers.length;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;max;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(action == <span class="string">"publish"</span>)&#123;</div><div class="line">                subscribers[i](arg);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span>(subscribers[i] === arg)&#123;</div><div class="line">                    subscribers.splice(i,<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//定义一个函数makePublisher()，它接受一个对象作为对象，通过把上述通用发布者的方法复制到该对象中，从而将其转换为一个发布者</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePublisher</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> i;</div><div class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> publisher) &#123;</div><div class="line">        <span class="keyword">if</span>(publisher.hasOwnProperty(i) &amp;&amp; <span class="keyword">typeof</span> publisher[i] === <span class="string">"function"</span>)&#123;</div><div class="line">            o[i] = publisher[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    o.subscribers = &#123;<span class="attr">any</span>: []&#125;;</div><div class="line">&#125;</div><div class="line"><span class="comment">//实现paper对象</span></div><div class="line"><span class="keyword">var</span> paper = &#123;</div><div class="line">    <span class="attr">daily</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.publish(<span class="string">"big news today"</span>);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">monthly</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.publish(<span class="string">"interesting analysis"</span>,<span class="string">"monthly"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//将paper构造成一个发布者</span></div><div class="line">makePublisher(paper);</div><div class="line"><span class="comment">//已经有了一个发布者。看看订阅对象joe，该对象有两个方法：</span></div><div class="line"><span class="keyword">var</span> joe = &#123;</div><div class="line">    <span class="attr">drinkCoffee</span>: <span class="function"><span class="keyword">function</span>(<span class="params">paper</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Just read'</span> + paper);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">sundayPreNap</span> : <span class="function"><span class="keyword">function</span>(<span class="params">monthly</span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'About to fall asleep reading this'</span> + monthly);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//paper注册joe（即joe向paper订阅）</span></div><div class="line">paper.subscribe(joe.drinkCoffee);</div><div class="line">paper.subscribe(joe.sundayPreNap,<span class="string">'monthly'</span>);</div><div class="line"><span class="comment">//即joe为默认“any”事件提供了一个可被调用的方法，而另一个可被调用的方法则用于当“monthly”类型的事件发生时的情况。现在让我们来触发一些事件：</span></div><div class="line">paper.daily();      <span class="comment">//Just readbig news today</span></div><div class="line">paper.daily();      <span class="comment">//Just readbig news today</span></div><div class="line">paper.monthly();    <span class="comment">//About to fall asleep reading thisinteresting analysis</span></div><div class="line">paper.monthly();    <span class="comment">//About to fall asleep reading thisinteresting analysis</span></div><div class="line">paper.monthly();</div></pre></td></tr></table></figure>
<p>试着用函数实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Publisher</span>(<span class="params">subscribers</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.subscribers = subscribers || &#123;<span class="string">'any'</span>: []&#125;;</div><div class="line">    Publisher.prototype.subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">fn, type</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> type = type || <span class="string">'any'</span>;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.subscribers[type] === <span class="string">'undefined'</span>)&#123;</div><div class="line">            <span class="keyword">this</span>.subscribers[type] = [];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.subscribers[type].push(fn);</div><div class="line">    &#125;;</div><div class="line">    Publisher.prototype.unsubscribe = <span class="function"><span class="keyword">function</span>(<span class="params">fn, type</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> type = type || <span class="string">'any'</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, len = <span class="keyword">this</span>.subscribers[type].length;  i&lt;len; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.subscribers[type][i] === fn)&#123;</div><div class="line">                <span class="keyword">this</span>.subscribers[type].splice(i,<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    Publisher.prototype.publish = <span class="function"><span class="keyword">function</span>(<span class="params">publication, type</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> type = type || <span class="string">'any'</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, len = <span class="keyword">this</span>.subscribers[type].length; i&lt;len; i++)&#123;</div><div class="line">            <span class="keyword">this</span>.subscribers[type][i](publication);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> paper = <span class="keyword">new</span> Publisher();</div><div class="line">paper.daily = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.publish(<span class="string">' this is Olympic ! '</span>);</div><div class="line">&#125;;</div><div class="line">paper.monthly = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.publish(<span class="string">' last month is the 28th Olympic! '</span>, <span class="string">'monthly'</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Jack = &#123;</div><div class="line">    <span class="attr">readInMorning</span>: <span class="function"><span class="keyword">function</span>(<span class="params">news</span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Jack reads '</span> + news + <span class="string">' in the morning'</span>);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">readInSunday</span>: <span class="function"><span class="keyword">function</span>(<span class="params">news</span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Jack reads '</span> + news + <span class="string">' on Sunday'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Amy = &#123;</div><div class="line">    <span class="attr">readInMorning</span>: <span class="function"><span class="keyword">function</span>(<span class="params">news</span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Amy reads '</span> + news + <span class="string">' in the morning'</span>);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">readInSunday</span>: <span class="function"><span class="keyword">function</span>(<span class="params">news</span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Amy reads '</span> + news + <span class="string">' on Sunday'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">paper.subscribe(Jack.readInMorning);</div><div class="line">paper.subscribe(Jack.readInSunday, <span class="string">'monthly'</span>);</div><div class="line">paper.subscribe(Amy.readInMorning);</div><div class="line">paper.subscribe(Amy.readInSunday, <span class="string">'monthly'</span>);</div><div class="line"></div><div class="line">paper.daily();          <span class="comment">//Jack reads  this is Olympic !  in the morning</span></div><div class="line">                        <span class="comment">//Amy reads  this is Olympic !  in the morning</span></div><div class="line">paper.monthly();        <span class="comment">//Jack reads  last month is the 28th Olympic!  on Sunday</span></div><div class="line">                        <span class="comment">//Amy reads  last month is the 28th Olympic!  on Sunday</span></div><div class="line"></div><div class="line">paper.unsubscribe(Jack.readInSunday,<span class="string">'monthly'</span>);</div><div class="line">paper.daily();              <span class="comment">//Jack reads  this is Olympic !  in the morning</span></div><div class="line">                            <span class="comment">//Amy reads  this is Olympic !  in the morning</span></div><div class="line">paper.monthly();            <span class="comment">//Amy reads  last month is the 28th Olympic!  on Sunday</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>观察者的使用场合就是：当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。<br>总的来说，观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/13/javascript技术难点（三）之this、new、apply和call详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="m">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="M'S BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/13/javascript技术难点（三）之this、new、apply和call详解/" itemprop="url">
                  javascript技术难点（三）之this、new、apply和call详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-13T11:14:39+08:00">
                2017-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>转载自伯乐在线<a href="http://blog.jobbole.com/81018/" target="_blank" rel="external">http://blog.jobbole.com/81018/</a></p>
</blockquote>
<p>讲解this指针的原理是个很复杂的问题，如果我们从javascript里this的实现机制来说明this，很多朋友可能会越来越糊涂，因此本篇打算换一个思路从应用的角度来讲解this指针，从这个角度理解this指针更加有现实意义。</p>
<p>下面我们看看在java语言里是如何使用this指针的，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> String sex;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="keyword">private</span> String job;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String sex, <span class="keyword">int</span> age, String job)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.sex = sex;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">        <span class="keyword">this</span>.job = job;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"姓名："</span> + <span class="keyword">this</span>.name);</div><div class="line">        System.out.println(<span class="string">"性别："</span> + <span class="keyword">this</span>.sex);</div><div class="line">        System.out.println(<span class="string">"年龄："</span> + <span class="keyword">this</span>.age);</div><div class="line">        System.out.println(<span class="string">"工作："</span> + <span class="keyword">this</span>.job);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.showPerson();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"马云"</span>, <span class="string">"男"</span>, <span class="number">46</span>, <span class="string">"董事长"</span>);</div><div class="line">        person.printInfo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//姓名：马云</span></div><div class="line"><span class="comment">//性别：男</span></div><div class="line"><span class="comment">//年龄：46</span></div><div class="line"><span class="comment">//工作：董事长</span></div></pre></td></tr></table></figure>
<p>上面的代码执行后没有任何问题，下面我修改下这个代码，加一个静态的方法，静态方法里使用this指针调用类里的属性，如下图所示：</p>
<p><img src="/2017/04/13/javascript技术难点（三）之this、new、apply和call详解/1.jpg" alt="1"></p>
<p>我们发现IDE会报出语法错误“Cannot use this in a static context”，this指针在java语言里是不能使用在静态的上下文里的。</p>
<p>在面向对象编程里有两个重要的概念：<strong>一个是类，一个是实例化的对象</strong>，类是一个抽象的概念，用个形象的比喻表述的话，类就像一个模具，而实例化对象就是通过这个模具制造出来的产品，实例化对象才是我们需要的实实在在的东西，类和实例化对象有着很密切的关系，但是在使用上类的功能是绝对不能取代实例化对象，就像模具和模具制造的产品的关系，二者的用途是不相同的。</p>
<p>有上面代码我们可以看到，<strong>this指针在java语言里只能在实例化对象里使用，this指针等于这个被实例化好的对象</strong>，而this后面加上点操作符，点操作符后面的东西就是this所拥有的东西，例如：姓名，工作，手，脚等等。</p>
<p>其实<strong>javascript里的this指针逻辑上的概念也是实例化对象</strong>，这一点和java语言里的this指针是一致的，但是javascript里的this指针却比java里的this难以理解的多，究其根本原因我个人觉得有三个原因：</p>
<p><strong>原因一：javascript是一个函数编程语言，怪就怪在它也有this指针，说明这个函数编程语言也是面向对象的语言，说的具体点，javascript里的函数是一个高阶函数，编程语言里的高阶函数是可以作为对象传递的，同时javascript里的函数还有可以作为构造函数，这个构造函数可以创建实例化对象，结果导致方法执行时候this指针的指向会不断发生变化，很难控制。</strong></p>
<p><strong>原因二：javascript里的全局作用域对this指针有很大的影响，由上面java的例子我们看到，this指针只有在使用new操作符后才会生效，但是javascript里的this在没有进行new操作也会生效，这时候this往往会指向全局对象window。</strong></p>
<p><strong>原因三：javascript里call和apply操作符可以随意改变this指向，这看起来很灵活，但是这种不合常理的做法破坏了我们理解this指针的本意，同时也让写代码时候很难理解this的真正指向</strong></p>
<p>上面的三个原因都违反了传统this指针使用的方法，它们都拥有有别于传统this原理的理解思路，而在实际开发里三个原因又往往会交织在一起，这就更加让人迷惑不解了，今天我要为大家理清这个思路，其实javascript里的this指针有一套固有的逻辑，我们理解好这套逻辑就能准确的掌握好this指针的使用。</p>
<p>我们先看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.a = <span class="string">"aaa"</span>;</div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">//aaa</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a);<span class="comment">//aaa</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);<span class="comment">//aaa</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// window</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>);<span class="comment">// window</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> == <span class="built_in">window</span>);<span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);<span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>在script标签里我们可以直接使用this指针，this指针就是window对象，我们看到即使使用三等号它们也是相等的。全局作用域常常会干扰我们很好的理解javascript语言的特性，这种干扰的本质就是：</p>
<p><strong>在javascript语言里全局作用域可以理解为window对象，记住window是对象而不是类，也就是说window是被实例化的对象，这个实例化的过程是在页面加载时候由javascript引擎完成的，整个页面里的要素都被浓缩到这个window对象，因为程序员无法通过编程语言来控制和操作这个实例化过程，所以开发时候我们就没有构建这个this指针的感觉，常常会忽视它，这就是干扰我们在代码里理解this指针指向window的情形。</strong></p>
<p>干扰的本质还和function的使用有关，我们看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ftn01</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"I am ftn01!"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> ftn02 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"I am ftn02!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是我们经常使用的<strong>两种定义函数的方式，第一种定义函数的方式在javascript语言称作声明函数，第二种定义函数的方式叫做函数表达式，</strong>这两种方式我们通常认为是等价的，但是它们其实是有区别的，而这个区别常常会让我们混淆this指针的使用，我们再看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(ftn01);<span class="comment">//ftn01()  注意：在firebug下这个打印结果是可以点击，点击后会显示函数的定义</span></div><div class="line"><span class="built_in">console</span>.log(ftn02);<span class="comment">// undefined</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ftn01</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"I am ftn01!"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> ftn02 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"I am ftn02!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这又是一段没有按顺序执行的代码，先看看ftn02，打印结果是undefined，undefined我在前文里讲到了，在内存的栈区已经有了变量的名称，但是没有栈区的变量值，同时堆区是没有具体的对象，这是javascript引擎在预处理（群里东方说预处理比预加载更准确，我同意他的说法，以后文章里我都写为预处理）扫描变量定义所致，但是ftn01的打印结果很令人意外，既然打印出完成的函数定义了，而且代码并没有按顺序执行，这只能说明一个问题：</p>
<p><strong>在javascript语言通过声明函数方式定义函数，javascript引擎在预处理过程里就把函数定义和赋值操作都完成了，在这里我补充下javascript里预处理的特性，其实预处理是和执行环境相关，在上篇文章里我讲到执行环境有两大类：全局执行环境和局部执行环境，执行环境是通过上下文变量体现的，其实这个过程都是在函数执行前完成，预处理就是构造执行环境的另一个说法，总而言之预处理和构造执行环境的主要目的就是明确变量定义，分清变量的边界，但是在全局作用域构造或者说全局变量预处理时候对于声明函数有些不同，声明函数会将变量定义和赋值操作同时完成，因此我们看到上面代码的运行结果。由于声明函数都会在全局作用域构造时候完成，因此声明函数都是window对象的属性，这就说明为什么我们不管在哪里声明函数，声明函数最终都是属于window对象的原因了。</strong></p>
<p>关于函数表达式的写法还有秘密可以探寻，我们看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ftn03</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> ftn04 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// window</span></div><div class="line">    &#125;;</div><div class="line">    ftn04();</div><div class="line">&#125;</div><div class="line">ftn03();</div></pre></td></tr></table></figure>
<p>运行结果我们发现ftn04虽然在ftn03作用域下，但是执行它里面的this指针也是指向window，其实函数表达式的写法我们大多数更喜欢在函数内部写，因为声明函数里的this指向window这已经不是秘密，但是函数表达式的this指针指向window却是常常被我们所忽视，特别是当它被写在另一个函数内部时候更加如此。</p>
<p><strong>其实在javascript语言里任何匿名函数都是属于window对象，它们也都是在全局作用域构造时候完成定义和赋值，但是匿名函数是没有名字的函数变量，但是在定义匿名函数时候它会返回自己的内存地址，如果此时有个变量接收了这个内存地址，那么匿名函数就能在程序里被使用了，因为匿名函数也是在全局执行环境构造时候定义和赋值，所以匿名函数的this指向也是window对象，所以上面代码执行时候ftn04的this也是指向window，因为javascript变量名称不管在那个作用域有效，堆区的存储的函数都是在全局执行环境时候就被固定下来了，变量的名字只是一个指代而已。</strong></p>
<p>这下子坏了，this都指向window，那我们到底怎么才能改变它了？</p>
<p>在本文开头我说出了this的秘密，<strong>this都是指向实例化对象，</strong>前面讲到那么多情况this都指向window，就是因为这些时候只做了一次实例化操作，而这个实例化都是在实例化window对象，所以this都是指向window。我们要把this从window变成别的对象，就得要让function被实例化，那如何让javascript的function实例化呢？答案就是使用<strong>new</strong>操作符。我们看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"sharpxiajun"</span>,</div><div class="line">    <span class="attr">job</span>:<span class="string">"Software"</span>,</div><div class="line">    <span class="attr">show</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Name:"</span> + <span class="keyword">this</span>.name + <span class="string">";Job:"</span> + <span class="keyword">this</span>.job);</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// Object &#123; name="sharpxiajun", job="Software", show=function()&#125;</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> otherObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">otherObj.name = <span class="string">"xtq"</span>;</div><div class="line">otherObj.job = <span class="string">"good"</span>;</div><div class="line">otherObj.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Name:"</span> + <span class="keyword">this</span>.name + <span class="string">";Job:"</span> + <span class="keyword">this</span>.job);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// Object &#123; name="xtq", job="good", show=function()&#125;</span></div><div class="line">&#125;;</div><div class="line">obj.show();<span class="comment">//Name:sharpxiajun;Job:Software</span></div><div class="line">otherObj.show();<span class="comment">//Name:xtq;Job:good</span></div></pre></td></tr></table></figure>
<p>这是我上篇讲到的关于this使用的一个例子，写法一是我们大伙都爱写的一种写法，里面的this指针不是指向window的，而是指向Object的实例，firebug的显示让很多人疑惑，其实Object就是面向对象的类，大括号里就是实例对象了，即obj和otherObj。Javascript里通过字面量方式定义对象的方式是new Object的简写，二者是等价的，目的是为了减少代码的书写量，可见即使不用new操作字面量定义法本质也是new操作符，所以通过new改变this指针的确是不过攻破的真理。</p>
<p>下面我使用javascript来重写本篇开头用java定义的类，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,sex,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.sex = sex;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.showPerson = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"姓名:"</span> + <span class="keyword">this</span>.name);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"性别:"</span> + <span class="keyword">this</span>.sex);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"年龄:"</span> + <span class="keyword">this</span>.age);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"工作:"</span> + <span class="keyword">this</span>.job);</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// Person &#123; name="马云", sex="男", age=46, 更多...&#125;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"马云"</span>, <span class="string">"男"</span>, <span class="number">46</span>, <span class="string">"董事长"</span>);</div><div class="line">person.showPerson();</div></pre></td></tr></table></figure>
<p>看this指针的打印，类变成了Person，这表明function Person就是相当于在定义一个类，在javascript里function的意义实在太多，<strong>function既是函数又可以表示对象，function是函数时候还能当做构造函数，javascript的构造函数我常认为是把类和构造函数合二为一，当然在javascript语言规范里是没有类的概念，但是我这种理解可以作为构造函数和普通函数的一个区别，这样理解起来会更加容易些。</strong></p>
<p>下面我贴出在《javascript高级编程》里对new操作符的解释：</p>
<p><strong>new操作符会让构造函数产生如下变化：</strong></p>
<p><strong>1. 创建一个新对象；</strong></p>
<p><strong>2. 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；</strong></p>
<p><strong>3. 执行构造函数中的代码（为这个新对象添加属性）；</strong></p>
<p><strong>4. 返回新对象</strong></p>
<p>关于第二点其实很容易让人迷惑，例如前面例子里的obj和otherObj，obj.show()，里面this指向obj，我以前文章讲到一个简单识别this方式就是看方法调用前的对象是哪个this就指向哪个，其实这个过程还可以这么理解，在全局执行环境里window就是上下文对象，那么在obj里局部作用域通过obj来代表了，这个window的理解是一致的。</p>
<p>第四点也要着重讲下，记住构造函数被new操作，要让new正常作用最好不能在构造函数里写return，没有return的构造函数都是按上面四点执行，有了return情况就复杂了，这个知识我会在讲prototype时候讲到。</p>
<p>Javascript还有一种方式可以改变this指针，这就是call方法和apply方法，call和apply方法的作用相同，就是参数不同，call和apply的第一个参数都是一样的，但是后面参数不同，apply第二个参数是个数组，call从第二个参数开始后面有许多参数。Call和apply的作用是什么，这个很重要，重点描述如下：</p>
<p><strong>Call和apply是改变函数的作用域（有些书里叫做改变函数的上下文）</strong></p>
<p>这个说明我们参见上面new操作符第二条：</p>
<p><strong>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；</strong></p>
<p><strong>Call和apply是将this指针指向方法的第一个参数。</strong></p>
<p>我们看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"sharpxiajun"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ftn</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(name);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">ftn(<span class="string">"101"</span>);</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"xtq"</span></div><div class="line">&#125;;</div><div class="line">ftn.call(obj,<span class="string">"102"</span>);</div></pre></td></tr></table></figure>
<p>结果如下所示：<br>    101<br>    sharpxiajun<br>    Window<br>    102<br>    xtq<br>    Object { name=”xtq”}</p>
<p>我们看到apply和call改变的是this的指向，这点在开发里很重要，开发里我们常常被this所迷惑，迷惑的根本原因我在上文讲到了，这里我讲讲表面的原因：</p>
<p><strong>表面原因就是我们定义对象使用对象的字面表示法，字面表示法在简单的表示里我们很容易知道this指向对象本身，但是这个对象会有方法，方法的参数可能会是函数，而这个函数的定义里也可能会使用this指针，如果传入的函数没有被实例化过和被实例化过，this的指向是不同，有时我们还想在传入函数里通过this指向外部函数或者指向被定义对象本身，这些乱七八糟的情况使用交织在一起导致this变得很复杂，结果就变得糊里糊涂。</strong></p>
<p>其实理清上面情况也是有迹可循的，就以定义对象里的方法里传入函数为例：</p>
<p><strong>情形一：传入的参数是函数的别名，那么函数的this就是指向window；</strong></p>
<p><strong>情形二：传入的参数是被new过的构造函数，那么this就是指向实例化的对象本身；</strong></p>
<p><strong>情形三：如果我们想把被传入的函数对象里this的指针指向外部字面量定义的对象，那么我们就是用apply和call</strong></p>
<p>我们可以通过代码看出我的结论，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"I am window"</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"sharpxiajun"</span>,</div><div class="line">    <span class="attr">job</span>:<span class="string">"Software"</span>,</div><div class="line">    <span class="attr">ftn01</span>:<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">        obj.show();</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">ftn02</span>:<span class="function"><span class="keyword">function</span>(<span class="params">ftn</span>)</span>&#123;</div><div class="line">        ftn();</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">ftn03</span>:<span class="function"><span class="keyword">function</span>(<span class="params">ftn</span>)</span>&#123;</div><div class="line">        ftn.call(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"姓名:"</span> + <span class="keyword">this</span>.name);</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"Person"</span>);</div><div class="line">obj.ftn01(p);</div><div class="line">obj.ftn02(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;);</div><div class="line">obj.ftn03(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2017/04/13/javascript技术难点（三）之this、new、apply和call详解/2.jpg" alt="2"></p>
<p>最后再总结一下：</p>
<p><strong>如果在javascript语言里没有通过new（包括对象字面量定义）、call和apply改变函数的this指针，函数的this指针都是指向window的。</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/13/谈谈javascript语法里一些难点问题（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="m">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="M'S BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/13/谈谈javascript语法里一些难点问题（二）/" itemprop="url">
                  谈谈javascript语法里一些难点问题（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-13T10:44:21+08:00">
                2017-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>转载自伯乐在线<a href="http://blog.jobbole.com/81011/" target="_blank" rel="external">http://blog.jobbole.com/81011/</a></p>
</blockquote>
<h2 id="3-作用域链相关的问题"><a href="#3-作用域链相关的问题" class="headerlink" title="3)    作用域链相关的问题"></a>3)    作用域链相关的问题</h2><p>作用域链是javascript语言里非常红的概念，很多学习和使用javascript语言的程序员都知道作用域链是理解javascript里很重要的一些概念的关键，这些概念包括this指针，闭包等等，它非常红的另一个重要原因就是作用域链理解起来太难，就算有人真的感觉理解了它，但是碰到很多实际问题时候任然会是丈二和尚摸不到头脑，例如上篇引子里讲到的例子，本篇要讲的主题就是作用域链，再无别的内容，希望看完本文的朋友能有所收获。</p>
<p>讲作用域链首先要从作用域讲起，下面是百度百科里对作用域的定义：</p>
<blockquote>
<p>作用域在许多程序设计语言中非常重要。 通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。 作用域的使用提高了程序逻辑的局部性，增强程序的可靠性，减少名字冲突。</p>
</blockquote>
<p>在我最擅长的服务端语言java里也有作用域的概念，java里作用域是以{}作为边界，不过在纯种的面向对象语言里我们没必要把作用域研究的那么深，也没必要思考复杂的作用域嵌套问题，因为这些语言关于作用域的深度运用并不会给我们编写的代码带来多大好处。但是在javascript里却大不相同，如果我们不能很好的理解javascript的作用域我们就没办法使用javascript编写出复杂的或者规模宏大的程序。</p>
<p>由百度百科里的定义，我们知道作用域的作用是保证变量的名字不发生冲突，用现实的场景来理解有个人叫做张三，张三虽然只是一个名字，但是认识张三的人根据名字就能唯一确认这个人到底是谁，但是这个世界上叫做张三的人可不止一个，特别是两个叫张三的人有交集的时候我们就要有个办法明确指定这个张三绝不是另外一个张三，这时我们可能会根据两大张三年龄的差异来区分：例如一个张三叫大张三，相对的另外一个张三叫小张三了。编程语言里的作用域其实就是为了做类似的标记，作用域会设定一个范围，在这个范围里我们是不会弄错变量的真实含义。</p>
<p>前面我讲到在java里通过{}来设置作用域，在{}里面的变量会得到保护，这种保护就是不让{}里的变量被外部变量混淆和污染。那么{}的方式适合于javascript吗？我们看看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="string">"sharpxiajun"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ftn</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> s2 = <span class="string">"xtq"</span>;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// 运行结果： window</span></div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"s1:"</span> + <span class="keyword">this</span>.s1 + <span class="string">";s2:"</span> + <span class="keyword">this</span>.s2);<span class="comment">//运行结果：s1:sharpxiajun;s2:undefined</span></div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"s1:"</span> + <span class="keyword">this</span>.s1 + <span class="string">";s2:"</span> + s2);<span class="comment">// 运行结果：s1:sharpxiajun;s2:xtq</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">ftn();</div></pre></td></tr></table></figure>
<p>在javascript世界里有一个大的作用域环境，这个环境就是window，window环境不需要我们自己使用什么方式构建，页面加载时候页面会自动构造的，上面代码里有一个大括号,这个大括号是对函数的定义，运行之，我们发现函数作用域内部定义的s2变量是不能被window对象访问的，因此s2变量是被{}保护起来了，它的生命周期和这个函数的生命周期有关。</p>
<p>由这个例子是不是说明在javascript里，变量也是被{}保护起来了，在javascript语言里还有非函数的{}，我们再看看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>)&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> a = <span class="string">"aaaa"</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">// 运行结果：aaaa</span></div></pre></td></tr></table></figure>
<p>我们发现javascript里{}有时是起不到定义作用域的功能。这也说明javascript里的作用域定义是和其他语言例如java不同的。</p>
<p>在javascript里作用域有一个专门的定义execution context，有的书里把这个名字翻译成执行上下文，有的书籍里把它翻译成执行环境，我更倾向于后者执行环境，下文我提到的执行环境就是execution context。这个命名非常形象，这个形象体现在execution这个单词，execution含义就是执行，我们来想想javascript里那些情况是执行：</p>
<p><strong>情况一：当页面加载时候在script标签下的javascript代码会按顺序执行，而这些能被执行的代码都是属于window的变量或函数；</strong></p>
<p><strong>情况二：当函数的名字后面加上小括号()，例如ftn()，这也是在执行，不过它执行的是函数。</strong></p>
<p><strong>如此说来，javascript里的执行环境有两类一类是全局执行环境，即window代表的全局环境，一类是函数代表的函数执行环境，这也就是我们常说的局部作用域。</strong></p>
<p>执行环境在javascript语言里并非是一个抽象的概念，而是有具体的实现，这个实现其实是个对象，这个对象也有个名字叫做variable object，这个变量有的书里翻译为变量对象，这是直译，有的书里把它称为上下文变量，这里我还是倾向于后者上下文变量，下文里提到的上下文变量就是指代variable object。上下文变量存储的是上下文变量所处执行环境里定义的所有的变量和函数。</p>
<p>全局执行环境的上下文变量是可以访问到的，它就是window对象，所以我们说window能代表全局作用域是有道理的，但是局部作用域即函数的执行环境里的上下文变量是代码不能访问到的，不过javascript引擎在处理数据时候会使用到它。</p>
<p><strong>在javascript语言里还有一个概念，它的名字叫做execution context stack，翻译成中文就是执行环境栈，每个要被执行的函数都会先把函数的执行环境压入到执行环境栈里，函数执行完毕后，这个函数的执行环境就会被执行环境栈弹出，例如上面的例子：函数执行时候函数的执行环境会被压入到执行环境栈里，函数执行完毕，执行环境栈会把这个环境弹出，执行环境栈的控制权就会交由全局环境，如果函数后面还有代码，那么代码就是接着执行。如果函数里嵌套了函数，那么嵌套函数执行完毕后，执行环境栈的控制权就交由了外部函数，然后依次类推，最后就是全局执行环境了。</strong></p>
<p>讲到这里我们大名鼎鼎的作用域链要登场了，函数的执行环境被压入到执行环境栈里后，函数就要执行了，函数执行的第一步不是执行函数里的第一行代码而是在上下文变量里构造一个作用域链，作用域链的英文名字叫做<strong>scope chain</strong>，作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，这个概念里有两个关键意思：有权访问和有序，我们看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b1 = <span class="string">"b1"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ftn1</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> b2 = <span class="string">"b2"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> b1 = <span class="string">"bbb"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ftn2</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> b3 = <span class="string">"b3"</span>;</div><div class="line"></div><div class="line">        b2 = b1;</div><div class="line"></div><div class="line">        b1 = b3;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"b1:"</span> + b1 + <span class="string">";b2:"</span> + b2 + <span class="string">";b3:"</span> + b3);<span class="comment">// 运行结果：b1:b3;b2:bbb;b3:b3</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ftn2();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">ftn1();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(b1);<span class="comment">// 运行结果：b1</span></div></pre></td></tr></table></figure>
<p>有这个例子我们发现，ftn2函数可以访问变量b1，b2，这个体现了有权访问的概念，当ftn1作用域里改变了b1的值并且把b1变量重新定义为ftn1的局部变量，那么ftn2访问到的b1就是ftn1的，ftn2访问到b1后就不会在全局作用域里查找b1了，这个体现了有序性。</p>
<p>下面我要总结下上面讲述的知识：</p>
<p><strong>本篇的小标题是：作用域链的相关问题，这个标题定义的含义是指作用域链是大名鼎鼎了，但是作用域链在广大程序员的理解里其实包含的意义已经超越了作用域链在javascript语言本身的定义。广大程序员对作用域链的理解有两块一块是作用域，而作用域在javascript语言里指的是执行环境execution context，执行环境在javascript引擎里是通过上下文变量体现的variable object，javascript引擎里还有一个概念就是执行环境栈execution context stack，当某一个函数的执行环境压入到了执行环境栈里，这个时候就会在上下文变量里构造一个对象，这个对象就是作用域链scope chain，而这个作用域链就是广大程序员理解的第二块知识，作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。</strong></p>
<p>很多人常常认为作用域链是理解this指针的关键，这个理解是不正确的的，this指针构造是和作用域链同时发生的，也就是说在上文变量构建作用域链的同时还会构造一个this对象，this对象也是属于上下文变量，而this变量的值就是当前执行环境外部的上下文变量的一份拷贝，这个拷贝里是没有作用域链变量的，例如代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b1 = <span class="string">"b1"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ftn1</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// 运行结果： window</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> b2 = <span class="string">"b2"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> b1 = <span class="string">"bbb"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ftn2</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// 运行结果： window</span></div><div class="line"></div><div class="line">        <span class="keyword">var</span> b3 = <span class="string">"b3"</span>;</div><div class="line"></div><div class="line">        b2 = b1;</div><div class="line"></div><div class="line">        b1 = b3;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"b1:"</span> + b1 + <span class="string">";b2:"</span> + b2 + <span class="string">";b3:"</span> + b3);<span class="comment">// 运行结果：b1:b3;b2:bbb;b3:b3</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ftn2();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">ftn1();</div></pre></td></tr></table></figure>
<p>我们看到函数ftn1和ftn2里的this指针都是指向window，这是为什么了？因为在javascript我们定义函数方式是通过function xxx(){}形式，那么这个函数不管定义在哪里，它都属于全局对象window，所以他们的执行环境的外部的执行上下文都是指向window。</p>
<p>但是我们都知道现实代码很多this指针都不是指向window，例如下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line"></div><div class="line">    <span class="attr">name</span>:<span class="string">"sharpxiajun"</span>,</div><div class="line"></div><div class="line">    <span class="attr">ftn</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// 运行结果: Object &#123; name="sharpxiajun", ftn=function()&#125;</span></div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);<span class="comment">//运行结果: sharpxiajun</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.ftn();<span class="comment">// ：</span></div></pre></td></tr></table></figure>
<p>运行之，我们发现这里this指针指向了Object，这就怪了我前文不是说javascript里作用域只有两种类型：一个是全局的一个是函数，为什么这里Object也是可以制造出作用域了，那么我的理论是不是有问题啊？那我们看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"></div><div class="line">obj1.name = <span class="string">"xtq"</span>;</div><div class="line"></div><div class="line">obj1.ftn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// 运行结果: Object &#123; name="xtq", ftn=function()&#125;</span></div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);<span class="comment">//运行结果: xtq</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">obj1.ftn();</div></pre></td></tr></table></figure>
<p>这两种写法是等价的，第一种对象的定义方法叫做字面量定义，而第二种写法则是标准写法，Object对象的本质也是个function，所以当我们调用对象里的函数时候，函数的外部执行环境就是obj1本身，即外部执行环境上下文变量代表的就是obj1，那么this指针也是指向了obj1。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/12/谈谈javascript语法里一些难点问题（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="m">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="M'S BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/12/谈谈javascript语法里一些难点问题（一）/" itemprop="url">
                  谈谈javascript语法里一些难点问题（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T16:42:40+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>转载自伯乐在线<a href="http://blog.jobbole.com/81010/" target="_blank" rel="external">http://blog.jobbole.com/81010/</a></p>
</blockquote>
<h2 id="1-先看这样一段代码"><a href="#1-先看这样一段代码" class="headerlink" title="1)   先看这样一段代码"></a>1)   先看这样一段代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(a);</div><div class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line">    alert(a);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果为：<br>//undefined<br>//3</p>
<p>这是一个令人诧异的结果，为什么第一个弹出框显示的是undefined，而不是1呢？这种疑惑的原理我描述如下：</p>
<p>一个页面里直接定义在script标签下的变量是全局变量即属于window对象的变量，按照javascript作用域链的原理，当一个变量在当前作用域下找不到该变量的定义，那么javascript引擎就会沿着作用域链往上找直到在全局作用域里查找，按上面的代码所示，虽然函数内部重新定义了变量的值，但是内部定义之前函数使用了该变量，那么按照作用域链的原理在函数内部变量定义之前使用该变量，javascript引擎应该会在全局作用域里找到变量定义，而实际情况却是变量未定义，这到底是怎么回事呢？</p>
<p>当时群里很多人都给出了问题的解答，我也给出了我自己的解答，其实这个问题很久之前我的确研究过，但是刚被问起了我居然还是有个卡壳期，在加上最近研究javascriptMVC的写法，发现自己读代码时候对new 、prototype、apply以及call的用法任然要体味半天，所以我觉得有必要对javascript基础语法里比较难理解的问题做个梳理，其实写博客的一个很大的好处就是写出来的知识逻辑会比你在脑子里反复梳理的逻辑映像更加的深刻。</p>
<p>下面开始本文的主要内容，我会从基础知识一步步讲起。</p>
<h2 id="2-JavaScript变量"><a href="#2-JavaScript变量" class="headerlink" title="2)   JavaScript变量"></a>2)   JavaScript变量</h2><p>Java语言里有一句很经典的话：<strong>在java的世界里，一切皆是对象</strong>。</p>
<p>Javascript虽然跟java没有半点毛关系，但是很多会使用javascript的朋友同样认为：<strong>在javascript的世界里，一切也皆是对象</strong>。</p>
<p>其实javascript语言和java语言一样变量是分为两种类型：基本数据类型和引用类型。</p>
<p>基本类型是指：Undefined、Null、Boolean、Number和String；而引用类型是指多个指构成的对象，所以javascript的对象指的是引用类型。在java里能说一切是对象，是因为java语言里对所有基本类型都做了对象封装，而这点在javascript语言里也是一样的，所以提在javascript世界里一切皆为对象也不为过。</p>
<p>但是实际开发里如果我们对基本类型和引用类型的区别不是很清晰，就会碰到我们很多不能理解的问题，下面我们来看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"sharpxiajun"</span>;</div><div class="line"> </div><div class="line">str.attr01 = <span class="string">"hello world"</span>;</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(str);<span class="comment">//  运行结果：sharpxiajun</span></div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(str.attr01);<span class="comment">// 运行结果：undefined</span></div></pre></td></tr></table></figure>
<p>运行之，我们发现作为基本数据类型，我们没法为这个变量添加属性，当然方法也同样不可以，例如下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"sharpxiajun"</span>;</div><div class="line"> </div><div class="line">str.attr01 = <span class="string">"hello world"</span>;</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(str);<span class="comment">//  运行结果：sharpxiajun</span></div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(str.attr01);<span class="comment">// 运行结果：undefined</span></div></pre></td></tr></table></figure>
<p>运行之，结果如下图所示：</p>
<p><img src="/2017/04/12/谈谈javascript语法里一些难点问题（一）/1.jpg" alt="1"></p>
<p>当我们使用引用类型时候，结果就和上面完全不同了，大家请看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"> </div><div class="line">obj1.name = <span class="string">"obj1 name"</span>;</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(obj1.name);<span class="comment">// 运行结果：obj1 name</span></div></pre></td></tr></table></figure>
<p>javascript里的基本类型和引用类型的区别和其他语言类似，这是一个老调长谈的问题，但是在现实中很多人都理解它，但是却很难应用它去理解问题。</p>
<p>Javascript里的基本变量是存放在栈区的（栈区指内存里的栈内存），它的存储结构如下图所示：</p>
<p><img src="/2017/04/12/谈谈javascript语法里一些难点问题（一）/2.jpg" alt="2"><br><img src="/2017/04/12/谈谈javascript语法里一些难点问题（一）/3.jpg" alt="3"></p>
<p>javascript里引用变量的存储就比基本类型存储要复杂多，引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，如下图所示：</p>
<p>在javascript里变量的存储包含三个部分：</p>
<p><strong>部分一：栈区的变量标示符；</strong></p>
<p><strong>部分二：栈区变量的值；</strong></p>
<p><strong>部分三：堆区存储的对象。</strong></p>
<p>变量不同的定义，这三个部分也会随之发生变化，下面我来列举一些典型的场景：</p>
<p><strong>场景一：如下代码所示：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> qqq;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(qqq);<span class="comment">// 运行结果：undefined</span></div></pre></td></tr></table></figure>
<p>运行结果是undefined，上面的代码的标准解释就是变量被命名了，但是还未初始化，此时在变量存储的内存里只拥有栈区的变量标示符而没有栈区的变量值，当然更没有堆区存储的对象。</p>
<p><strong>场景二：如下代码所示：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> qqq;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(qqq);<span class="comment">// 运行结果：undefined</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(xxx);<span class="comment">// 运行结果：xxx is not defined</span></div></pre></td></tr></table></figure>
<p>会提示变量未定义。在任何语言里变量未定义就使用都是违法的，我们看到javascript里也是如此，但是我们做javascript开发时候，经常有人会说变量未定义也是可以使用，怎么我的例子里却不能使用了？那么我们看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">xxx = <span class="string">"outer xxx"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(xxx);<span class="comment">// 运行结果：outer xxx</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFtn</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">     sss = <span class="string">"inner sss"</span>;</div><div class="line"></div><div class="line">     <span class="built_in">console</span>.log(sss);<span class="comment">// 运行结果：outer sss</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">testFtn();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(sss);<span class="comment">//运行结果：inner sss</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.sss);<span class="comment">//运行结果：inner sss</span></div></pre></td></tr></table></figure>
<p><strong>由这两个场景我们可以知道在javascript里的变量不能正常使用即报出“xxx is not defined”错误（这个错误下，后续的javascript代码将不能正常运行）只有当这个变量既没有被var定义同时也没有进行赋值操作才会发生，而只有赋值操作的变量不管这个变量在那个作用域里进行的赋值，这个变量最终都是属于全局变量即window对象。</strong></p>
<p>由上面我列举的两个场景我们来理解下引子里网友提出的问题，下面我修改一下代码，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hehe</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">     <span class="built_in">console</span>.log(a); <span class="comment">//unfined</span></div><div class="line"></div><div class="line">     <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line"></div><div class="line">     <span class="built_in">console</span>.log(a); <span class="comment">//2</span></div><div class="line"></div><div class="line">&#125;</div><div class="line">hehe();</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hehe</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> </div><div class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//a is not defined</span></div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line"> </div><div class="line">&#125;</div><div class="line">hehe();</div></pre></td></tr></table></figure>
<p>对比二者代码以及引子里的代码，我们发现问题的关键是var a=2所引起的。在代码一里我注释了全局变量的定义，结果和引子里代码的结果一致，这说明函数内部a变量的使用和全局环境是无关的，代码二里我注释了关键代码var a = 2，代码运行结果发生了变化，程序报错了，的确很让人困惑，困惑之处在于局部作用域里变量定义的位置在变量第一次使用之后，但是程序没有报错，这不符合javascript变量未定义既要报错的原理。</p>
<p>其实这个变量任然被定义即内存存储里有了标示符，只不过没有被赋值，代码一则说明，内部变量a已经和外部环境无关，怎么回事？如果我们按照代码运行是按照顺序执行的逻辑来理解，这个代码也就没法理解。</p>
<p>其实javascript里的变量和其他语言有很大的不同，javascript的变量是一个松散的类型，松散类型变量的特点是变量定义时候不需要指定变量的类型，变量在运行时候可以随便改变数据的类型，但是这种特性并不代表javascript变量没有类型，当变量类型被确定后javascript的变量也是有类型的。但是在现实中，很多程序员把javascript松散类型理解为了javascript变量是可以随意定义即你可以不用var定义，也可以使用var定义，其实在javascript语言里变量定义没有使用var，变量必须有赋值操作，只有赋值操作的变量是赋予给window，这其实是javascript语言设计者提升javascript安全性的一个做法。</p>
<p>此外javascript语言的松散类型的特点以及运行时候随时更改变量类型的特点，很多程序员会认为javascript变量的定义是在运行期进行的，更有甚者有些人认为javascript代码只有运行期，其实这种理解是错误的，<strong>javascript代码在运行前还有一个过程就是：预加载，预加载的目的是要事先构造运行环境例如全局环境，函数运行环境，还要构造作用域链（关于作用域链和环境，本文后续会做详细的讲解），而环境和作用域的构造的核心内容就是指定好变量属于哪个范畴，因此在javascript语言里变量的定义是在预加载完成而非在运行时期。</strong></p>
<p>所以，引子里的代码在函数的局部作用域下变量a被重新定义了，在预加载时候a的作用域范围也就被框定了，a变量不再属于全局变量，而是属于函数作用域，只不过赋值操作是在运行期执行（这就是为什么javascript语言在运行时候会改变变量的类型，因为赋值操作是在运行期进行的），所以第一次使用a变量时候，a变量在局部作用域里没有被赋值，只有栈区的标示名称，因此结果就是undefined了。</p>
<p>不过赋值操作也不是完全不对预加载产生影响，预加载时候javascript引擎会扫描所有代码，但不会运行它，当预加载扫描到了赋值操作，但是赋值操作的变量有没有被var定义，那么该变量就会被赋予全局变量即window对象。</p>
<p>根据上面的内容我们还可以理解下javascript两个特别的类型：undefined和null，从javascript变量存储的三部分角度思考，当变量的值为undefined时候，那么该变量只有栈区的标示符，如果我们对undefined的变量进行赋值操作，如果值是基本类型，那么栈区的值就有值了，如果栈区是对象那么堆区会有一个对象，而栈区的值则是堆区对象的地址，如果变量值是null的话，我们很自然认为这个变量是对象，而且是个空对象，按照我前面讲到的变量存储的三部分考虑：<strong>当变量为null时候，栈区的标示符和值都会有值，堆区应该也有，只不过堆区是个空对象，这么说来null其实比undefined更耗内存了</strong>，那么我们看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ooo = <span class="literal">null</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ooo);<span class="comment">// 运行结果：null</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ooo == <span class="literal">undefined</span>);<span class="comment">// 运行结果：true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ooo == <span class="literal">null</span>);<span class="comment">// 运行结果：true</span></div><div class="line"></div><div class="line"> <span class="built_in">console</span>.log(ooo === <span class="literal">undefined</span>);<span class="comment">// 运行结果：false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ooo === <span class="literal">null</span>);<span class="comment">// 运行结果：true</span></div></pre></td></tr></table></figure>
<p>运行之，结果很震惊啊，null居然可以和undefined相等，但是使用更加精确的三等号“===”，发现二者还是有点不同，其实javascript里undefined类型源自于null即null是undefined的父类，本质上null和undefined除了名字这个马甲不同，其他都是一样的，不过要让一个变量是null时候必须使用等号“=”进行赋值了。</p>
<p>当变量为undefined和null时候我们如果滥用它javascript语言可能就会报错，后续代码会无法正常运行，所以javascript开发规范里要求变量定义时候最好马上赋值，赋值好处就是我们后面不管怎么使用该变量，程序都很难因为变量未定义而报错从而终止程序的运行，例如上文里就算变量是string基本类型，在变量定义属性程序还是不会报错，这是提升程序健壮性的一个重要手段，由引子的例子我们还知道，变量定义最好放在变量所述作用域的最前端，这么做也是保证代码健壮性的一个重要手段。</p>
<p>下面我们再看一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">undefined</span> != str &amp;&amp; <span class="literal">null</span> != str &amp;&amp; <span class="string">""</span> != str)&#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"true"</span>);</div><div class="line"></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"false"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">undefined</span> != str &amp;&amp; <span class="string">""</span> != str)&#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"true"</span>);</div><div class="line"></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"false"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">null</span> != str &amp;&amp; <span class="string">""</span> != str)&#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"true"</span>);</div><div class="line"></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"false"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!!str)&#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"true"</span>);</div><div class="line"></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"false"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">str = <span class="string">""</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!!str)&#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"true"</span>);</div><div class="line"></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"false"</span>);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行之，结果都是打印出false。</p>
<p>使用双等号“==”，undefined和null是一回事，所以第一个if语句的写法完全多余，增加了不少代码量，而第二种和第三种写法是等价，究其本质前三种写法本质都是一致的，但是现实中很多程序员会选用写法一，原因就是他们还没理解undefined和null的不同，第四种写法是更加完美的写法，在javascript里如果if语句的条件是undefined和null，那么if判断的结果就是false，使用！运算符if计算结果就是true了，再加一个就是false，所以这里我建议在书写javascript代码时候判断代码是否为未定义和null时候最好使用！运算符。</p>
<p>代码四里我们看到当字符串被赋值了，但是赋值是个空字符串时候，if的条件判断也是false，javascript里有五种基本类型，undefined、null、boolean、Number和string，现在我们发现除了Number都可以使用！来判断if的ture和false，那么基本类型Number呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!!num)&#123;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"true"</span>);</div><div class="line"></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"false"</span>);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行之，结果是false。</p>
<p>如果我们把num改为负数或正数，那么运行之的结果就是true了。</p>
<p>这说明了一个道理：我们定义变量初始化值的时候，如果基本类型是string，我们赋值空字符串，如果基本类型是number我们赋值为0，这样使用if语句我们就可以判断该变量是否是被使用过了。</p>
<p>但是当变量是对象时候，结果却不一样了，如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!!obj)&#123;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"true"</span>);</div><div class="line"></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"false"</span>);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行之，代码是true。</p>
<p>所以在定义对象变量时候，初始化时候我们要给变量赋予null，这样if语句就可以判断变量是否初始化过。</p>
<p>其实if加上！运算判断对象的现象还有玄机，这个玄机要等我把场景三讲完才能说清楚哦。</p>
<p><strong>场景三：复制变量的值和函数传递参数</strong></p>
<p>代码1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="string">"sharpxiajun"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> s2 = s1;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(s1);<span class="comment">//// 运行结果：sharpxiajun</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(s2);<span class="comment">//// 运行结果：sharpxiajun</span></div><div class="line"></div><div class="line">s2 = <span class="string">"xtq"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(s1);<span class="comment">//// 运行结果：sharpxiajun</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(s2);<span class="comment">//// 运行结果：xtq</span></div></pre></td></tr></table></figure>
<p>代码2</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"> </div><div class="line">obj1.name = <span class="string">"obj1 name"</span>;</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(obj1.name);<span class="comment">// 运行结果：obj1 name</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> obj2 = obj1;</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(obj2.name);<span class="comment">// 运行结果：obj1 name</span></div><div class="line"> </div><div class="line">obj1.name = <span class="string">"sharpxiajun"</span>;</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(obj2.name);<span class="comment">// 运行结果：sharpxiajun</span></div></pre></td></tr></table></figure>
<p>我们发现当复制的是对象，那么obj1和obj2两个对象被串联起来了，obj1变量里的属性被改变时候，obj2的属性也被修改。</p>
<p>函数传递参数的本质就是外部的变量复制到函数参数的变量里，我们看看下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFtn</span>(<span class="params">sNm,pObj</span>)</span>&#123;</div><div class="line"> </div><div class="line">        <span class="built_in">console</span>.log(sNm);<span class="comment">// 运行结果：new Name</span></div><div class="line"> </div><div class="line">        <span class="built_in">console</span>.log(pObj.oName);<span class="comment">// 运行结果：new obj</span></div><div class="line"> </div><div class="line">        sNm = <span class="string">"change name"</span>;</div><div class="line"> </div><div class="line">        pObj.oName = <span class="string">"change obj"</span>;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> sNm = <span class="string">"new Name"</span>;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> pObj = &#123;<span class="attr">oName</span>:<span class="string">"new obj"</span>&#125;;</div><div class="line"> </div><div class="line">testFtn(sNm,pObj);</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(sNm);<span class="comment">// 运行结果：new Name</span></div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(pObj.oName);<span class="comment">// 运行结果：change obj</span></div></pre></td></tr></table></figure>
<p>这个结果和变量赋值的结果是一致的。</p>
<p><strong>在javascript里传递参数是按值传递的。</strong></p>
<p>上面函数传参的问题是很多公司都爱面试的问题，其实很多人都不知道javascript传参的本质是怎样的，如果把上面传参的例子改的复杂点，很多朋友都会栽倒到这个面试题下。</p>
<p>为了说明这个问题的原理，就得把上面讲到的变量存储原理综合运用了，这里我把前文的内容再复述一遍，两张图，如下所示：</p>
<p><img src="/2017/04/12/谈谈javascript语法里一些难点问题（一）/2.jpg" alt="2"><br><img src="/2017/04/12/谈谈javascript语法里一些难点问题（一）/3.jpg" alt="3"></p>
<p>这是引用类型存储的内存结构。</p>
<p>还有个知识,如下：</p>
<p>在javascript里变量的存储包含三个部分：</p>
<p><strong>部分一：栈区的变量标示符；</strong></p>
<p><strong>部分二：栈区变量的值；</strong></p>
<p><strong>部分三：堆区存储的对象。</strong></p>
<p>在javascript里变量的复制（函数传参也是变量赋值）本质是传值，这个值就是栈区的值，而基本类型的内容是存放在栈区的值里，所以复制基本变量后，两个变量是独立的互不影响，但是当复制的是引用类型时候，复制操作还是复制栈区的值，但是这个时候值是堆区对象的地址，因为javascript语言是不允许操作堆内存，因此堆内存的变量并没有被复制，所以复制引用对象复制的值就是堆内存的地址，而复制双方的两个变量使用的对象是相同的，因此复制的变量其中一个修改了对象，另一个变量也会受到影响。</p>
<p>原理讲完了，下面我列举一个拔高的例子，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ftn1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> </div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"test:ftn1"</span>);</div><div class="line"> </div><div class="line">    &#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> ftn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> </div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"test:ftn2"</span>);</div><div class="line"> </div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ftn</span>(<span class="params">f</span>)</span>&#123;</div><div class="line"> </div><div class="line">       f();</div><div class="line"> </div><div class="line">       f = ftn2;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">ftn(ftn1);<span class="comment">// 运行结果：test:ftn1</span></div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(<span class="string">"====================华丽的分割线======================"</span>);</div><div class="line"> </div><div class="line">ftn1();<span class="comment">// 运行结果：test:ftn1</span></div></pre></td></tr></table></figure>
<p>这个代码是很早之前有位朋友考我的，我当时答对了，但是我是蒙的，问我的朋友答错了，其实当时我们两个都没搞懂其中缘由，我朋友是这么分析的他认为f是函数的参数，属于函数的局部作用域，因此更改f的值，是没法改变ftn1的值，因为到了外部作用域f就失效了，但是这种解释很难说明我上文里给出的函数传参的实例，其实这个问题答案就是函数传参的原理，只不过这里加入了个混淆因素函数，在javascript函数也是对象，局部作用域里f = ftn2操作是将f在栈区的地址改为了ftn2的地址，对外部的ftn1和ftn2没有任何改变。</p>
<p><strong>记住：javascript里变量复制和函数传参都是在传递栈区的值。</strong></p>
<p>栈区的值除了变量复制起作用，它在if语句里也会起到作用，当栈区的值为undefined、null、“”（空字符串）、0、false时候，if的条件判断则是为false，我们可以通过！运算符计算，因此当我们的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (!!obj)&#123;</div><div class="line"> </div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"true"</span>);</div><div class="line"> </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line"> </div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"false"</span>);</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果则是true，因为var obj = {}相当于var obj = new Object(),虽然对象里没什么内容，但是在堆区里，对象的内存已经分配了，而变量栈区的值已经是内存地址了，所以if语句判断就是true了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="m" />
          <p class="site-author-name" itemprop="name">m</p>
           
              <p class="site-description motion-element" itemprop="description">双手扶着后腰，双眼透着贫穷</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">m</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  








  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
